package commandHelp;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang3.StringUtils;

import coloring.Xterm256;
import exceptions.InvalidColourException;
import exceptions.InvalidCommandLineException;
import jline.console.ConsoleReader;
import jline.console.completer.StringsCompleter;

public class CommandList {
	
	private static String SEE_ALSO= "\nFull documentation at: http://asciigenome.readthedocs.io/\n";
	
	public static ConsoleReader initConsole() throws IOException, InvalidColourException{
		
		Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
		    public void run() {
		    	System.out.print("\033[0m"); // On exit turn off all formatting
		    }
		}));
		
		ConsoleReader console= new ConsoleReader(); 
		try {
			// Autcomplete commands with length > x 
			for(CommandHelp x : CommandList.commandHelpList()){
				if(x.getName().length() > 2){
					console.addCompleter(new StringsCompleter(x.getName()));
				}
			}
		} catch (InvalidCommandLineException e) {
			e.printStackTrace();
		}
		console.setExpandEvents(false);
		return console;
	}
	
	private static String reStructuredTextHelp() throws InvalidCommandLineException, InvalidColourException{

		String intro = ".. _command_reference:"
				+ "\n"
				+ "\n"
				+ ".. This document is autogenerated by CommandList.reStructuredTextHelp().\n"
				+ "   Do not edit it here. Edit source code then run tests in CommandListTest.updateReStructuredFile() to recreate "
				+ "this file.\n\n";

		intro += ""
				+ "Command reference\n"
         		+ "=================\n\n";
		intro += "This is the documentation for the indvidual commands. "
				+ "The help documented here can be invoked also at the command prompt with `command -h`, for example to "
				+ "get the help for `ylim`::\n"
				+ "\n"
				+ "    ylim -h\n"
				+ "\n"
				+ "Parameters in square brakets are optional and the default argument is "
				+ "indicated by the `=` sign. The syntax `...` indicate that the argument "
				+ "can be repeated multiple times. For example::\n"
				+ "\n"
				+ "    ylim min max [track_regex = .*]...\n"
				+ "\n"
				+ "Means that `ylim` takes two mandatory arguments, `min` and `max`. The optional "
				+ "argument, `track_regex`, defaults to `.*` and can be repated multiple times.\n";
				
		String help= "";
		for(Section sec : Section.values()){
			
			help += toTitleCase(sec.toString() + "\n") + StringUtils.repeat("-", sec.toString().length()) + "\n\n";

			for(CommandHelp x : CommandList.getCommandsForSection(sec)){
								
				help += x.getPrintName() + "\n" + StringUtils.repeat("+", x.getPrintName().length()) + "\n\n"; 
				help += ":code:`" + (x.getName() + " " + x.getArgs()).trim() + "`\n\n";
				help += (x.getBriefDescription() + " " + x.getAdditionalDescription() + "\n\n");
			}			
		}
		// Handle special cases manually:
		help= help.replace("[incl_regex = .*]", "[incl_regex = .\\*]");
		
		help= help.replaceAll("~", " ");
		return intro + "\n\n" + help;
	}
	
	/** Run this method in Unit test to update the file commandHelp.md  
	 * @throws InvalidCommandLineException 
	 * @throws IOException 
	 * @throws InvalidColourException 
	 * */
	public static void updateCommandHelpMdFile(File destFile) throws InvalidCommandLineException, IOException, InvalidColourException{
		
		BufferedWriter wr= new BufferedWriter(new FileWriter(destFile));
		String doc= reStructuredTextHelp();
		
		// Replace ansi escapes
		doc= doc.replaceAll("\n*0: [\\s|\\S]+0m", "`colors here <http://jonasjacek.github.io/colors/>`_");
		// doc= doc.replaceAll("\\d+: \\033\\[38;5;\\d+m", ".. raw:: html\n\n    <font color=\"").replaceAll("\\033\\[0m\\s*", "\">FOO</font>\n\n----\n\n");
		
		wr.write(doc + "\n");
		wr.close();
		System.err.println("Command help file written to " + destFile.getAbsolutePath());
	}
	
	public static String fullHelp() throws InvalidCommandLineException, InvalidColourException{
		String help= "\n      N a v i g a t i o n \n\n";
		for(CommandHelp x : CommandList.getCommandsForSection(Section.NAVIGATION)){
			help += (x.printCommandHelp() + "\n");
		}
		help += "\n      F i n d \n\n";
		for(CommandHelp x : CommandList.getCommandsForSection(Section.FIND)){
			help += (x.printCommandHelp() + "\n");
		}
		help += "\n      D i s p l a y \n\n";
		for(CommandHelp x : CommandList.getCommandsForSection(Section.DISPLAY)){
			help += (x.printCommandHelp() + "\n");
		}
		
		help += "\n      A l i g n m e n t s \n\n";
		for(CommandHelp x : CommandList.getCommandsForSection(Section.ALIGNMENTS)){
			help += (x.printCommandHelp() + "\n");
		}

		for(CommandHelp x : CommandList.getCommandsForSection(Section.GENERAL)){
			help += (x.printCommandHelp() + "\n");
		}
		
		help += "\n      G e n e r a l \n\n";
		for(CommandHelp x : CommandList.getCommandsForSection(Section.GENERAL)){
			help += (x.printCommandHelp());
		}
		help += SEE_ALSO;
		return help;
	}
	
	public static String briefHelp() throws InvalidCommandLineException, InvalidColourException{
		String help= "\n      N a v i g a t i o n \n\n";
		for(CommandHelp x : CommandList.getCommandsForSection(Section.NAVIGATION)){
			help += (x.printBriefHelp());
		}
		help += "\n      F i n d \n\n";
		for(CommandHelp x : CommandList.getCommandsForSection(Section.FIND)){
			help += (x.printBriefHelp());
		}
		help += "\n      D i s p l a y \n\n";
		for(CommandHelp x : CommandList.getCommandsForSection(Section.DISPLAY)){
			help += (x.printBriefHelp());
		}
		
		help += "\n      A l i g n m e n t s \n\n";
		for(CommandHelp x : CommandList.getCommandsForSection(Section.ALIGNMENTS)){
			help += (x.printBriefHelp());
		}
		help += "\n      G e n e r a l \n\n";
		for(CommandHelp x : CommandList.getCommandsForSection(Section.GENERAL)){
			help += (x.printBriefHelp());
		}
		help += SEE_ALSO;
		return help;
	}

	
	private final static List<CommandHelp> commandHelpList() throws InvalidCommandLineException, InvalidColourException{
		List<CommandHelp> cmdList= new ArrayList<CommandHelp>();
		CommandHelp cmd= new CommandHelp();		

		cmd= new CommandHelp();
		cmd.setName("goto"); cmd.setArgs("chrom:[from]-[to]"); cmd.inSection= Section.NAVIGATION; 
		cmd.setBriefDescription("Go to region `chrom:from-to` or to `chrom:from` or to the start of `chrom`. "); 
		cmd.setAdditionalDescription("The character ':' is a shortcut for `goto`. Examples::\n"
				+ "\n"
				+ "    goto chr8:1-1000~~## Go to interval 1-1000 on chr8\n"
				+ "    goto chr8:10~~~~~~## Go to position 10 on chr8\n"
				+ "    goto chr8~~~~~~~~~## Go to start of chr8\n"
				+ "\n"
				+ "Or the same with::\n"
				+ "\n"
				+ "    :chr8:1-1000 \n"
				+ "    :chr8:10 \n"
				+ "    :chr8"
				+ "\n");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("INT"); cmd.setArgs("[INT]"); cmd.inSection= Section.NAVIGATION; 
		cmd.setBriefDescription(""
				+ "Go to position `INT` or to region `INT INT` on current chromosome. ");
		cmd.setAdditionalDescription(""
				+ "Allowed is the hyphenated format  separating the two positions. "
				+ "If a list of integers is given, the first and last are taken as *from* and *to*. "
				+ "This is handy to copy and paste intervals from the ruler above the prompt. "
				+ "\nExamples::\n"
				+ "\n"
				+ "    10~~~~~~~~~~~~~~~~~~~-> Will jump to position 10 \n"
				+ "    10 1000~~~~~~~~~~~~~~-> Go to region 10-1000 \n"
				+ "    10-1000~~~~~~~~~~~~~~-> Same as above\n"
				+ "    10 250 500 750 1000~~-> Same as above again\n"
				+ "\n");
		cmdList.add(cmd);
		
		cmd= new CommandHelp();
		cmd.setName("+"); cmd.setArgs("INT [k|m]"); cmd.inSection= Section.NAVIGATION; cmd.setPrintName("plus +");
		cmd.setBriefDescription("Move forward by `INT` bases. Suffix K/M recognized. ");
		cmd.setAdditionalDescription("Suffixes k (kilo) and M (mega) are expanded to x1000 and x1,000,000. "
				+ "Examples::\n"
				+ "\n"
				+ "    +2m\n"
				+ "    +10k\n"
				+ "    +10.5k\n"
				+ "\n"); 
		cmdList.add(cmd);
		
		cmd= new CommandHelp();
		cmd.setName("-"); cmd.setArgs("INT [k|m]"); cmd.inSection= Section.NAVIGATION; cmd.setPrintName("minus -"); 
		cmd.setBriefDescription("Move backwards by INT bases. Suffix K/M recognized. ");
		cmd.setAdditionalDescription("Suffixes k (kilo) and M (mega) are expanded to x1000 and x1,000,000.\n"
				+ "Examples::\n"
				+ "\n"
				+ "    -100\n"
				+ "    -10k\n"
				+ "    -10.5m\n"
				+ "\n"); 
		cmdList.add(cmd);
		
		cmd= new CommandHelp(); 
		cmd.setName("f"); cmd.setArgs("[NUM=0.1]"); cmd.inSection= Section.NAVIGATION; cmd.setPrintName("f - forward");
		cmd.setBriefDescription("Move forward NUM times the size of the current window, 1/10 by default.");  
		cmdList.add(cmd);
		
		cmd= new CommandHelp(); 
		cmd.setName("b"); cmd.setArgs("[NUM=0.1]"); cmd.inSection= Section.NAVIGATION; cmd.setPrintName("b - backward");
		cmd.setBriefDescription("Move backward NUM times the size of the current window, 1/10 by default"); 
		cmdList.add(cmd);
		
		cmd= new CommandHelp();
		cmd.setName("ff"); cmd.setArgs(""); cmd.inSection= Section.NAVIGATION;
		cmd.setBriefDescription("Move forward by 1/2 of a window. A shortcut for `f 0.5`");  
		cmdList.add(cmd);
		
		cmd= new CommandHelp();
		cmd.setName("bb"); cmd.setArgs(""); cmd.inSection= Section.NAVIGATION; 
		cmd.setBriefDescription("Move backward by 1/2 of a window. A shortcut for `b 0.5`"); 
		cmdList.add(cmd);
						
		cmd= new CommandHelp();
		cmd.setName("zi"); cmd.setArgs("[INT = 1]"); cmd.inSection= Section.NAVIGATION; 
		cmd.setBriefDescription("Zoom in INT times. Each zoom halves the window size. "); 
		cmd.setAdditionalDescription("To zoom quickly use INT=~5 or 10 e.g. `zi~10`");
		cmdList.add(cmd);
		
		cmd= new CommandHelp();
		cmd.setName("zo"); cmd.setArgs("[INT = 1]"); cmd.inSection= Section.NAVIGATION; 
		cmd.setBriefDescription("Zoom out INT times. Each zoom doubles the window size. ");
		cmd.setAdditionalDescription("To zoom quickly use INT=~5 or 10 e.g. `zo 10`");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("extend"); cmd.setArgs("[mid|window] [INT left] [INT right]"); cmd.inSection= Section.NAVIGATION; 
		cmd.setBriefDescription("Extend the current window by `INT` bases left and right.\n");
		cmd.setAdditionalDescription("\n"
				+ "* :code:`window` (default): Extend the current window left and right by `INT` bases\n"
				+ "\n"
				+ "* :code:`mid` The new window is given by the midpoint of the current window "
				+ "plus and minus `INT` bases left and right.\n"
				+ "\n"
				+ "If only one INT is given it is applied to both left and right. Negative INTs will shrink "
				+ "instead of extend the window.");
		cmdList.add(cmd);
		
//		cmd= new CommandHelp();
//		cmd.setName("trim"); cmd.setArgs("track_name"); cmd.inSection= Section.NAVIGATION; 
//		cmd.setBriefDescription("Trim current coordinates to remove empty regions around `track_name`. ");
//		cmd.setAdditionalDescription("With `track_name` missing, trim on the first annotation track found. "
//				+ "`track_name` can partially match the actual, full track name if multiple "
//				+ "matches occur the first track matched is trimmed.\n"
//				+ "Note that the window is not trimmed if the trimmed window is smaller than the user window size (e.g. trimmed 20bp with window 100bp).");
//		cmdList.add(cmd);
		
		cmd= new CommandHelp();
		cmd.setName("l"); cmd.setArgs(""); cmd.inSection= Section.NAVIGATION; cmd.setPrintName("l - left");
		cmd.setBriefDescription("Go to the Left half of the current window. ");
		cmd.setAdditionalDescription("Alternate the left and right command to quickly focus on a point of interest. ");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("r"); cmd.setArgs(""); cmd.inSection= Section.NAVIGATION; cmd.setPrintName("r - right");
		cmd.setBriefDescription("Go to the Right half of the current window. ");
		cmd.setAdditionalDescription("Alternate the left and right command to quickly focus on a point of interest. ");
		cmdList.add(cmd);
		
		cmd= new CommandHelp();
		cmd.setName("p"); cmd.setArgs(""); cmd.inSection= Section.NAVIGATION; 
		cmd.setBriefDescription("Go to the previous visited position. ");
		cmd.setAdditionalDescription("Similar to the back and forward arrows of an Internet browser.");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("n"); cmd.setArgs(""); cmd.inSection= Section.NAVIGATION; 
		cmd.setBriefDescription("Go to the next visited position. ");
		cmd.setAdditionalDescription("Similar to the back and forward arrows of an Internet browser.");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("next"); cmd.setArgs("[-back] [-start] [-zo INT=5] [track]"); cmd.inSection= Section.NAVIGATION; 
		cmd.setBriefDescription("Move to the next feature not overlapping the current coordinates. "); 
		cmd.setAdditionalDescription(""
				+ "By default `next` centers the window on the next feature and zooms out.\n"
				+ "\n"
				+ "* :code:`-back` Search backwards. I.e. move to next feature on the left of the current position.\n"
				+ "\n"
				+ "* :code:`-start` Sets the window right at the start of the feature, without centering and zooming out.\n"
				+ "\n"
				+ "* :code:`-zo INT` Zoom out INT times after having found the next feature. "
				+ "  Ignored if the `-start` flag is set. If <= 0 the window spans exactly the feature coordinates. "
				+ "  Default 5.\n"
				+ "\n"
				+ "* :code:`track` Track to search for next feature. Default to the first annotation track found.\n"
				+ "\n"
				+ "`next` starts searching immediately after the current window and loops thourgh each chromosome until a feature is found.");
 

		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("find"); cmd.setArgs("[-all] regex [track]"); cmd.inSection= Section.FIND; 
		cmd.setBriefDescription("Find the first record in `track` containing `regex`."); 
		cmd.setAdditionalDescription(""
				+ "The search for `regex` starts from the *end* of the current window "
				+ "(so the current window is not searched) and moves forward on the current chromosome. "
				+ "At the end  of the current chromosome move to the next chromosomes and then restart at "
				+ " the start of the initial one. The search stops at the first match found. If `track` is omitted "
				+ "the first interval track found is searched.\n"
				+ "The :code:`-all` flag will return the region containing **all** the regex matches.\n"
				+ "Examples::\n"
				+ "\n"
				+ "    find -all ACTB genes.gtf~-> Find all the matches of ACTB\n"
				+ "    find 'ACTB gene'~~~~~~~~~-> Find the first match of 'ACTB gene'\n"
				+ "\n"
				+ "Use single quotes to define patterns containing spaces."); 
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("seqRegex"); cmd.setArgs("[-iupac] [-c] [regex]"); cmd.inSection= Section.FIND; 
		cmd.setBriefDescription("Find regex in reference sequence and show matches as an additional track. ");
		cmd.setAdditionalDescription("Options:\n"
				+ "\n"
				+ "* :code:`regex` Regex to search. If missing the seq regex track is removed.\n"
				+ "\n"
				+ "* :code:`-iupac` Enable the interpretation of the IUPAC ambiguity code. NB: "
				+ "This option simply converts IUPAC chracters to the corresponding regex.\n"
				+ "\n"
				+ "* :code:`-c` Enable case-sensitive matching. Default is to ignore case.\n"
				+ "\n"
				+ "Examples::\n"
				+ "\n"
				+ "    seqRegex~ACTG~~~~~~~~-> Case insensitive, actg matched\n"
				+ "    seqRegex -c ACTG ~~~~-> Case sensitive, will not match actg\n"
				+ "    seqRegex -iupac ARYG~-> Interpret (converts) R as [AG] and Y as [CT]\n"
				+ "    seqRegex~~~~~~~~~~~~~-> Disable regex matching track\n"
				+ "\n"
				+ "To save matches to file, see the `print` command. This command is ignored if the reference fasta sequence is missing."
				+ "");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("bookmark"); cmd.setArgs("[name] | [-rm] | [-print] | [> [file]]"); cmd.inSection= Section.FIND; 
		cmd.setBriefDescription("Creates a track to save positions of interest.");
		cmd.setAdditionalDescription(""
				+ "Without arguments, add the current position to the bookmark track. Options:\n"
				+ "\n"
				+ "* :code:`name` give this name to the new bookmark.\n"
				+ "\n"
				+ "* :code:`-rm` remove the bookmark matching *exactly* the current position.\n"
				+ "\n"
				+ "* :code:`-print` prints to screen the list of current bookmarks.\n"
				+ "\n"
				+ "* :code:`>` saves the bookmark track to file.\n"
				+ "\n"
				+ "Examples::\n"
				+ "\n"
				+ "    bookmark~~~~~~~~~~~~~~-> Add the current position to bookmarks.\n"
				+ "    bookmark myGene ~~~~~~-> Add the current position with name myGene\n"
				+ "    bookmark -rm ~~~~~~~~~-> Remove the bookmark exactly in this position\n"
				+ "    bookmark > books.txt~~-> Save to file books.txt\n"
				+ "    bookmark -print ~~~~~~-> Show table of bookmarks\n"
				+ "\n"
				+ "");
		cmdList.add(cmd);

		
		cmd= new CommandHelp();
		cmd.setName("grep"); cmd.setArgs("[-i = .*] [-e = ''] [-v] [track_regex = .*]..."); cmd.inSection= Section.DISPLAY; 
		cmd.setBriefDescription("Similar to grep command, filter for features including or excluding patterns.");
		cmd.setAdditionalDescription(""
				+ "Options:\n"
				+ "\n"
				+ "* :code:`-i regex`  Show features matching this regex.\n"
				+ "\n"
				+ "* :code:`-e regex` Exclude features matching this regex.\n"
				+ "\n"
				+ "* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex\n"
				+ "\n"
				+ "* :code:`track_regex` Apply to tracks matched by `track_regex`.\n"
				+ "\n"
				+ "*NOTES*\n"
				+ "\n"
				+ "* For case insensitive matching prepend :code:`(?i)` to regex pattern. E.g. :code:`-i (?i)ACTB` to match also Actb\n"
				+ "\n"
				+ "* Use *single quotes* to delimit patterns containing spaces e.g. :code:`-i 'ACTB gene'`\n"
				+ "\n"
				+ "Regex `-i` and `-e` are applied to the raw lines as read from source file and "
				+ "it is applied only to annotation tracks (GFF, BED, VCF, etc). For example::\n"
				+ "\n"
				+ "    grep -i RNA -e mRNA gtf gff\n"
				+ "\n"
				+ "Will show the rows containing 'RNA' but will hide those containing 'mRNA', applies "
				+ "to tracks whose name matches 'gtf' or 'gff'."
				+ ""
				+ "\nWith no arguments reset to default: :code:`grep -i .* -e ^$ .*` which means show everything, hide nothing, apply to all tracks."
				);
		cmdList.add(cmd);		

		cmd= new CommandHelp();
		cmd.setName("awk"); cmd.setArgs("[-off ...] [-F sep_re] [-v VAR=var] [-V] '<script>' [track_regex = .*]..."); cmd.inSection= Section.DISPLAY; 
		cmd.setBriefDescription("Advanced feature filtering using awk syntax.");
		cmd.setAdditionalDescription("awk offers finer control then :code:`grep` to filter records in tabular format.\n"
				+ "\n"
				+ "Awk is column oriented. Awk splits each line into a list using a given regular "
				+ "expression as delimiter (default delimiter is the TAB "
				+ "character). To access an item, i.e. a column, use "
				+ "the syntax :code:`$n` where *n* is the position of the item in the list, "
				+ "e.g. :code:`$3` will access the third field (i.e. 3rd column). "
				+ "The variable :code:`$0` holds the entire line as single string.\n"
				+ "\n"
				+ "Awk understands numbers and mathematical operators. "
				+ "With awk you can filter records by numeric values in one or more fields since"
				+ " numbers are handled as such. You can also perform arithmetic operations and filter on the results.\n"
				+ "\n"
				+ "*OPTIONS*\n"
				+ "\n"
				+ "* :code:`-off track_re ...`  Turn off awk filtering for tracks captured by the list of regexes.\n"
				+ "\n"
				+ "* :code:`-F <sep_re>` Use regular expression <sep_re> as column separator. Default is '\\t' (tab). "
				+ "To separate on white space use e.g. '\\b' (backspace) or '\\s' (any white space). Do not use ' '. \n"
				+ "\n"
				+ "* :code:`-v VAR=var` Pass to awk script the variable VAR with value var. Can be repeated.\n"
				+ "\n"
				+ "* :code:`script` The awk script to be executed. Must wrapped in single quotes.\n"
				+ "\n"
				+ "* :code:`-V` Invert selection: apply changes to the tracks not selected by list of track_regex\n"
				+ "\n"
				+ "*EXAMPLES*\n"
				+ "\n"
				+ "Note the use of single quotes to wrap the actual script and the use of "
				+ "double quotes inside the script.\n"
				+ "\n"
				+ "* Filter for lines where the 4th column is between 10 and 100. Apply only to tracks "
				+ "matching '.gtf' or '.gff'::\n"
				+ "\n"
				+ "    awk '$4 > 10 && $4 <= 100' .gtf .gff\n"
				+ "\n"
				+ "* Filter for either perfect a match or by matching a regex on 3rd column. "
				+ "Apply to all tracks. The second example matches regex on the entire line (similar to grep), "
				+ "The third example also requires features to be on + strand::\n"
				+ "\n"
				+ "    awk '$3 == \"exon\" || $3 \\~ \".*_codon\"'\n"
				+ "    \n"
				+ "    awk '$0 \\~ \".*_codon\"'\n"
				+ "    \n"
				+ "    awk '($3 == \"exon\" || $3 \\~ \".*_codon\") && $7 == \"+\"'\n"
				+ "\n"
				+ "* Filter for features size (assuming bed format) and for values after log10 transformation. "
				+ "For log10 we need to change base using ln(x)/ln(10)::\n"
				+ "\n"
				+ "    awk '($3 - $2) > 1000 && (log($4)/log(10)) < 3.5'\n"
				+ "\n"
				+ "* Remove awk filter for tracks captured by .gff and .gtf::\n"
				+ "\n"
				+ "    awk -off .gtf .gff\n"
				+ "\n"
				+ "With no args, turn off awk for all tracks.\n"
				+ "\n"
				+ "*NOTES & LIMITATIONS*\n"
				+ "\n"
				+ "* This is a java implementation of awk and it is independent on whether awk is "
				+ "on the local system. It should behave very similar to UNIX awk and therefore it has lots of "
				+ "functionalities. "
				+ "In fact, awk is a programming language in itself, search Google for more. "
				+ "The original code is from https://github.com/hoijui/Jawk\n"
				+ "\n"
				+ "* Use awk only to filter features, do not use it to edit them. If features are "
				+ "changed by the awk script than nothing will be retained. This is because "
				+ "the awk command first collects the output from awk, then it matches the features in "
				+ "the current window with those collected from awk.\n"
				+ "\n"
				+ "* Each line is processed independently of the others as a separate awk execution. "
				+ "This means that you cannot filter one line on the bases of previous or following lines.\n"
				+ "\n"
				+ "* This awk is slow, about x10-100 times slower than UNIX awk. For few thousand records "
				+ "the slowdown should be acceptable. Other things being equal, use `grep` instead.\n"
				+ "\n"
				+ "* The default delimiter is TAB not any white space as in UNIX awk.\n"
				+ "\n"
				+ "* An invalid script throws an ugly stack trace to stderr. To be fixed.");
		cmdList.add(cmd);
		
		cmd= new CommandHelp();
		cmd.setName(Command.featureDisplayMode.toString()); cmd.setArgs("[-expanded | -collapsed | -oneline] [-v] [track_regex = .*]..."); cmd.inSection= Section.DISPLAY; 
		cmd.setBriefDescription("Set how annotation features should be displayed.\n");
		cmd.setAdditionalDescription("\n"
				+ "* :code:`-expanded/-e` Put overalpping features on different lines (default).\n"
				+ "\n"
				+ "* :code:`-collapsed/-c` Merge features with overlapping genomic coordinates.\n"
				+ "\n"
				+ "* :code:`-oneline/-o` Merge features overlapping on screen coordinates. This option makes the track "
				+ "occupy only one line.\n"
				+ "\n"
				+ "* :code:`-v` Invert selection: apply changes to tracks not selected by list of track_regex\n"
				+ "\n"
				+ "* :code:`track_regex` List of regexes to select tracks. Default: .* (all tracks).\n"
				+ "\n"
				+ "Without arguments toggle between expanded and collapsed mode. ");
		cmdList.add(cmd);		

		cmd= new CommandHelp();
		cmd.setName("gap"); cmd.setArgs("[-on | -off] [-v] [track_regex = .*]..."); cmd.inSection= Section.DISPLAY; 
		cmd.setBriefDescription("Display features with or without a separating gap. ");
		cmd.setAdditionalDescription("With :code:`gap -on` (default) features which on screen do not have "
				+ "at least one space separating them are moved to different lines. In this way it is clear where one "
				+ "feature starts and ends. "
				+ "If gap is unset (:code:`gap -off`) features are shown more packed.\n"
				+ "\n"
				+ ":code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex\n"
				+ "\n"
				+ "Example with :code:`gap -on`::\n"
				+ "\n"
				+ "    ||||||\n"
				+ "    ~~~~~~||||||\n"
				+ "\n"
				+ "With :code:`gap -off` these two features look like::\n"
				+ "\n"
				+ "    ||||||||||||\n"
				+ "\n"
				+ "As elsewhere, this command is applied to all tracks captured by the list of regexes.");
		cmdList.add(cmd);		

		
		cmd= new CommandHelp();
		cmd.setName("gffNameAttr"); cmd.setArgs("[attribute_name = NULL | -na] [-v] [track_regex = .*]..."); cmd.inSection= Section.DISPLAY; 
		cmd.setBriefDescription("GTF/GFF attribute to set the feature name or `-na` to suppress name. ");
		cmd.setAdditionalDescription("Use attribute NULL to reset to default choice of attribute. To suppress "
				+ "printing of the name use `-na`. Bed features get their name from the 4th column. "
				+ "Applies to annotation tracks captured by the list `track_regex`.\n"
				+ "\n"
				+ ":code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex\n"
				+ "\n"
				+ "Example, given "
				+ "the gtf feature::\n"
				+ "\n"
				+ "    chr1 . CDS  10 99 . + 2 gene_id \"PTGFRN\"; transcript_id \"NM_020440\";\n"
				+ "\n"
				+ "Use gene_name as feature name or transcript_id::\n"
				+ "\n"
				+ "    gffNameAttr gene_name genes.gtf .*gff\n"
				+ "    PTGFRN_CCCCCCCCC\n"
				+ "    \n"
				+ "    gffNameAttr transcript_id genes.gtf .*gff\n"
				+ "    NM_020440_CCCCCC\n"
				+ "    \n"
				+ "    gffNameAttr -na\n"
				+ "    CCCCCCCCCCCCCCCC <- Do not show name"
				+ "    \n"
				+ "\n");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("trackHeight"); cmd.setArgs("[-v] INT [track_regex = .*]..."); cmd.inSection= Section.DISPLAY; 
		cmd.setBriefDescription("Set track height to INT lines of text for all tracks matching regexes. ");
		cmd.setAdditionalDescription("Setting height to zero hides the track and skips the processing altogether. "
				+ "This is useful to speed up the browsing when large bam files are present. Use infoTrack "
				+ "to see which tracks are hidden.\n"
				+ "\n"
				+ ":code:`-v` Invert selection: apply changes to tracks not selected by list of track_regex\n"
				+ "\n"
				+ "Example::\n"
				+ "\n"
				+ "    trackHeight 5 aln.*bam gtf`"
				+ "\n");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("ylim"); cmd.setArgs("[-v] <NUM|min|na> <NUM|min|na> [track_regex = .*]..."); cmd.inSection= Section.DISPLAY; 
		cmd.setBriefDescription("Set the y-axis limit for all tracks matched by regexes.");
		cmd.setAdditionalDescription("The first two arguments set the min and max limits. The 3rd "
				+ "argument is a list of regexes to capture the tracks to reset. "
				+ "Argument min and max can be:\n"
				+ "\n"
				+ "* :code:`NUM` Numeric, fix the limits exactly to these values\n"
				+ "\n"
				+ "* :code:`na` Scale tracks to their individual min and/or max\n"
				+ "\n"
				+ "* :code:`min` and :code:`max` Set to the min and max of **all** tracks.\n"
				+ "\n"
				+ ":code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex\n"
				+ "\n"
				+ "This command applies only to tracks displaying quantitative data on y-axis (e.g. bigwig, tdf), "
				+ "the other tracks are unaffected. Examples::\n"
				+ "\n"
				+ "    ylim 0 50~~~~~~-> Set min= 0 and max= 50 in all tracks.\n"
				+ "    ylim 0 na~~~~~~-> Set min to 0 and autoscale the max. Apply to all tracks\n"
				+ "    ylim na na tdf~-> Autoscale min and max. Apply to all tracks matching 'tdf'\n"
				+ "    ylim min max~~~-> Set to the min and max of all tracks\n"
				+ "\n");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("colorTrack"); cmd.setArgs("[-v] color [track_regex = .*]..."); cmd.inSection= Section.DISPLAY; 
		cmd.setBriefDescription("Set colour for tracks matched by regex. ");
		cmd.setAdditionalDescription(""
				+ "Colors can be specified by name or by a value between 0 and 255. "
				+ "If only the start of a color is given, the first name found starting with "
				+ "the given string is returned, e.g. 'darkv' is interpreted as 'darkviolet'. "
				+ "Names are case insensitive.\n"
				+ "\n"
				+ ":code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex\n"
				+ "\n"
				+ "Available colours are from the Xterm256 palette: \n"
				+ "\n"
				+ Xterm256.colorShowForTerminal().replaceAll(" ", "~") 
				+ "\n"
				+ "\n"
				+ "Example::\n"
				+ "\n"
				+ "    colorTrack cyan1 ts.*gtf ts.*bam \n"
				+ "    colorTrack 40 ~~~~~~~~~~~~~~~~~~<- By INT\n"
				+ "    colorTrack darkv ~~~~~~~~~~~~~~~<- Same as darkviolet\n"
				+ "\n");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("hideTitle"); cmd.setArgs("[-on | -off] [-v] [track_regex = .*]..."); cmd.inSection= Section.DISPLAY; 
		cmd.setBriefDescription("Set the display of the title line matched by track_regex. ");
		cmd.setAdditionalDescription(""
				+ "Without argument -on or -off toggle between the two modes for all "
				+ "tracks matched by the list of regexes.\n"
				+ "\n"
				+ ":code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex\n"
				+ "");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("editNames"); cmd.setArgs("[-t] [-v] <pattern> <replacement> [track_re=.*]..."); cmd.inSection= Section.DISPLAY; 
		cmd.setBriefDescription("Edit track names by substituting regex pattern with replacement.");
		cmd.setAdditionalDescription("Pattern and replacement are required arguments, "
				+ "the default regex for track is '.*' (i.e. all tracks).\n"
				+ "\n"
				+ "* :code:`-t` (test) flag shows what renaming would be done without actually editing the names.\n"
				+ "\n"
				+ "* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex\n"
				+ "\n"
				+ "Use \"\" (empty double quotes) to replace pattern with nothing. "
				+ "Examples: Given track names 'fk123_hela.bam#1' and 'fk123_hela.bed#2'::\n"
				+ "\n"
				+ "    editNames fk123_ \"\"~~~~~~~-> hela.bam#1, hela.bed#2\n"
				+ "    editNames fk123_ \"\" bam ~~-> hela.bam#1, fk123_hela.bed#2\n"
				+ "    editNames _ ' ' ~~~~~~~~~~-> fk123 hela.bam#1,  fk123 hela.bed#2\n"
				+ "    editNames ^.*# cells ~~~~~-> cells#1, cells#2\n"
				+ "    editNames ^ xx_ ~~~~~~~~~~-> xx_fk123_hela.bam#1, xx_fk123_hela.bed#2 (add prefix)\n"
				+ "");
		cmdList.add(cmd);

		
		
		cmd= new CommandHelp();
		cmd.setName("dataCol"); cmd.setArgs("[-v] [index = 4] [track_regex = .*]..."); cmd.inSection= Section.DISPLAY; 
		cmd.setBriefDescription("Select data column for bedgraph tracks containing regex. ");
		cmd.setAdditionalDescription("First column has index 1. This command applies only to "
				+ "tracks of type bedgraph.\n"
				+ "\n"
				+ ":code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex\n"
				+ "\n"
				+ "For example, use column 5 on tracks containing #1 and #3::\n "
				+ "\n"
				+ "    dataCol 5 #1 #3\n"
				+ "\n");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName(Command.print.toString()); cmd.setArgs("[-n INT] [-full] [-off] [-v] [track_regex = .*]... [>|>> file]"); cmd.inSection= Section.DISPLAY; 
		cmd.setBriefDescription("Print lines for the tracks matched by `track_regex`. ");
		cmd.setAdditionalDescription("Useful to show exactly what features are present in the current window. "
				+ "Features are filtered in/out according to the :code:`grep` command. Options:\n"
				+ "\n"
				+ "* :code:`track_regex` Apply to tracks matched by one or more of these regexes.\n"
				+ "\n"
				+ "* :code:`-n INT=10` Print up to this many lines, default 10. No limit if < 0.\n"
				+ "\n"
				+ "* :code:`-clip` Clip lines longer than the screen width. This is the default.\n"
				+ "\n"
				+ "* :code:`-full` Wrap lines longer than the screen width.\n"
				+ "\n"
				+ "* :code:`-off` Turn off printing.\n"
				+ "\n"
				+ "* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex\n"
				+ "\n"
				+ "* :code:`>` and :code:`>>` Write output to `file`. `>` overwrites and `>>` appends to existing file. "
				+ "The %r variable in the filename is expanded to the current genomic coordinates. Writing to file overrides "
				+ "options -n and -off, lines are written in full without limit.\n"
				+ "\n"
				+ "Examples::\n"
				+ "\n"
				+ "    print~~~~~~~~~~~~~~~~~~~~~~~~-> Print all tracks, same as `print .*`\n"
				+ "    print -off~~~~~~~~~~~~~~~~~~~-> Turn off printing for all tracks\n"
				+ "    print genes.bed >> genes.txt~-> Append features in track(s) 'genes.bed' to file\n"
				+ "\n"
				+ "Currently `print` applies only to annotation tracks, other tracks are unaffected. Without options "
				+ "toggle tracks between OFF and CLIP mode.");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("setGenome"); cmd.setArgs("fasta|bam|genome"); cmd.inSection= Section.GENERAL; 
		cmd.setBriefDescription("Set genome and reference sequence.");
		cmd.setAdditionalDescription("The genome, i.e. the list of contig and names and sizes, "
				+ "can be extracted from the fasta reference, from a bam file or from "
				+ "a genome identifier (e.g. hg19). If a fasta file is used also the "
				+ "reference sequence becomes available.");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("setConfig"); cmd.setArgs("tag|file"); cmd.inSection= Section.GENERAL; 
		cmd.setBriefDescription("Set color configuration.");
		cmd.setAdditionalDescription("Configuration can be set with one of the built-in "
				+ "themes: 'black_on_white', 'white_on_black', 'metal'. "
				+ "Alternatively, configuration can be read from file. For examples "
				+ "files see \n"
				+ "https://github.com/dariober/ASCIIGenome/blob/master/resources/config/\n"
				+ "\n"
				+ "Examples:\n"
				+ "setConfig metal\n"
				+ "setConfig /path/to/mytheme.conf");
		cmdList.add(cmd);

		
		cmd= new CommandHelp();
		cmd.setName("showGenome"); cmd.setArgs(""); cmd.inSection= Section.GENERAL; 
		cmd.setBriefDescription("Print the genome dictionary with a representation of chromosome sizes. ");
		cmd.setAdditionalDescription("Example output::\n"
				+ "\n"
				+ "    showGenome\n"
				+ "    chrM  16571\n"
				+ "	   chr1  249250621 ||||||||||||||||||||||||||||||\n"
				+ "    chr2  243199373 |||||||||||||||||||||||||||||\n"
				+ "    ...\n"
				+ "    chr21 48129895~~||||||\n"
				+ "    chr22 51304566~~||||||\n"
				+ "    chrX  155270560 |||||||||||||||||||\n"
				+ "    chrY  59373566~~|||||||\n"
				+ "\n"
				+ "");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("infoTracks"); cmd.setArgs(""); cmd.inSection= Section.GENERAL; 
		cmd.setBriefDescription("Print the name of the current tracks along with file name and format. ");
		cmd.setAdditionalDescription("Hidden tracks are marked by an asterisk.");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("recentlyOpened"); cmd.setArgs("[-grep = .*]"); cmd.inSection= Section.GENERAL; 
		cmd.setBriefDescription("List recently opened files. ");
		cmd.setAdditionalDescription("Files are listed with their absolute path.\n"
				+ "\n"
				+ "* :code:`-n INT` Return only the last INT files.\n"
				+ "\n"
				+ "* :code:`-grep <pattern>` Filter for files (strings) matching pattern. "
				+ "Use single quotes to define patterns containing spaces, e.g. :code:`-grep 'goto chr1'`.");
		cmdList.add(cmd);
		
		cmd= new CommandHelp();
		cmd.setName("addTracks"); cmd.setArgs("[file or URL]..."); cmd.inSection= Section.GENERAL; 
		cmd.setBriefDescription("Add tracks from local or remote files. ");
		cmd.setAdditionalDescription("For local files, glob characters (wildcard) are expanded as in Bash "
				+ "(but note that currently globs in directory names are not expanded.)\n"
				+ "Examples::\n"
				+ "\n"
				+ "    addTracks peaks.bed genes.*.gtf\n"
				+ "    addTracks http://remote/host/peaks.bed\n"
				+ "");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("dropTracks"); cmd.setArgs("[-t] [-v] track_regex [track_regex]..."); cmd.inSection= Section.GENERAL; 
		cmd.setBriefDescription("Drop tracks matching any of the listed regexes.");
		cmd.setAdditionalDescription(""
				+ "* :code:`-t` (test) flag only shows which tracks would be removed but do not remove them.\n"
				+ "\n"
				+ "* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex\n"
				+ "\n"
				+ "Examples::\n"
				+ "\n"
				+ "    dropTracks bam\n"
				+ "");
		cmdList.add(cmd);

		
		cmd= new CommandHelp();
		cmd.setName("orderTracks"); cmd.setArgs("[track_regex]..."); cmd.inSection= Section.GENERAL; 
		cmd.setBriefDescription("Reorder tracks according to the list of regexes or sort by name.");
		cmd.setAdditionalDescription("Not all the tracks need to be listed, the missing ones "
				+ "follow the listed ones in unchanged order. Without arguments sort track by tag name.\n"
				+ "For example, given the track list: `[hela.bam#1, hela.bed#2, hek.bam#3, hek.bed#4]`::\n"
				+ "\n"
				+ "    orderTracks #2 #1~~~->~[hela.bed#2, hela.bam#1, hek.bam#3, hek.bed#4]\n"
				+ "    orderTracks bam bed~->~[hela.bam#1, hek.bam#3, hela.bed#2, hek.bed#4]\n"
				+ "    orderTracks~~~~~~~~~->~name sort~[hela.bam#1, hela.bed#2, hek.bam#3, hek.bed#4]\n"
				+ "");
		cmdList.add(cmd);
		
		cmd= new CommandHelp();
		cmd.setName("posHistory"); cmd.setArgs("[-n INT=10]"); cmd.inSection= Section.GENERAL; 
		cmd.setBriefDescription("List the visited positions.");
		cmd.setAdditionalDescription("Recorded positions include the current and the previous "
				+ "sessions of ASCIIGenome.\n"
				+ "\n"
				+ ":code:`-n INT` Show only the last INT positions. Show all if <= 0.");
		cmdList.add(cmd);
		
		cmd= new CommandHelp();
		cmd.setName("history"); cmd.setArgs("[-n INT] [-grep = .*]"); cmd.inSection= Section.GENERAL; 
		cmd.setBriefDescription("List the executed commands. ");
		cmd.setAdditionalDescription("Commands executed in previous sessions of ASCIIGenome are in \\~/.asciigenome_history\n"
				+ "\n"
				+ "* :code:`-n INT` Return only the last INT commands.\n"
				+ "\n"
				+ "* :code:`-grep <pattern>` Filter for commands (strings) matching pattern. "
				+ "Use single quotes to define patterns containing spaces, e.g. :code:`-grep 'goto chr1'`");
		cmdList.add(cmd);
		
		cmd= new CommandHelp();
		cmd.setName(Command.rpm.getCmdDescr()); cmd.setArgs("[-on | -off] [-v] [track_regex = .*]"); cmd.inSection= Section.ALIGNMENTS; 
		cmd.setBriefDescription("Set display to reads per million for BAM and TDF files.\n");
		cmd.setAdditionalDescription("\n"
				+ "* :code:`-on | -off` Set mode on/off. Without arguments toggle between on and off.\n"
				+ "\n"
				+ "* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex\n"
				+ "\n"
				+ "* :code:`track_regex` List of regexes to capture target tracks.");
		cmdList.add(cmd);		

		cmd= new CommandHelp();
		cmd.setName("samtools"); cmd.setArgs("[-f INT=0] [-F INT=4] [-q INT=0] [-v] [track_re = .*] ..."); cmd.inSection= Section.ALIGNMENTS; 
		cmd.setBriefDescription("Apply samtools filters to alignment tracks captured by the list of track regexes.");
		cmd.setAdditionalDescription("As *samtools view*, this command filters alignment records on the basis "
				+ "of the given flags:\n"
				+ "\n"
				+ "* :code:`-F` Filter out flags with these bits set. NB: 4 is always set.\n"
				+ "\n"
				+ "* :code:`-f` Require alignment to have these bits sets.\n"
				+ "\n"
				+ "* :code:`-q` Require alignments to have MAPQ >= than this.\n"
				+ "\n"
				+ "* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex\n"
				+ "\n"
				+ "Examples::\n"
				+ "\n"
				+ "    samtools -q 10~~~~~~~~~~~-> Set mapq for all tracks. -f and -F reset to default\n"
				+ "    samtools -F 1024 foo bar -> Set -F for all track containing re foo or bar\n"
				+ "    samtools~~~~~~~~~~~~~~~~~-> Reset all to default.\n"
				+ "");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName(Command.BSseq.getCmdDescr()); cmd.setArgs("[-on | -off] [-v] [track_regex = .*]..."); cmd.inSection= Section.ALIGNMENTS; 
		cmd.setBriefDescription("Set bisulfite mode for read tracks matched by regex.");
		cmd.setAdditionalDescription("In bisulfite mode, the characters M and m mark methylated bases "
				+ "(i.e. unconverted C to T) and U and u are used for unmethylated bases "
				+ "(i.e. C converted to T). Upper case is used for reads on  forward strand, small case for reverse.\n"
				+ "\n"
				+ "* :code:`-on | -off` Set mode. Without arguments toggle between on and off.\n"
				+ "\n"
				+ "* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex\n"
				+ "\n"
				+ "* :code:`track_regex` List of regexes to capture target tracks.\n"
				+ "\n"
				+ "Ignored without reference fasta sequence.");
		cmdList.add(cmd);		

		//cmd= new CommandHelp();
		//cmd.setName("pileup"); cmd.setArgs("[track_regex = .*]..."); cmd.inSection= Section.ALIGNMENTS; 
		//cmd.setBriefDescription("Print pileup of nucleotide counts.");
		//cmd.setAdditionalDescription("...");
		//cmdList.add(cmd);		
		
		cmd= new CommandHelp();
		cmd.setName("save"); cmd.setArgs("[>>] [filename = chrom_start_end.txt']"); cmd.inSection= Section.GENERAL; 
		cmd.setBriefDescription("Save screenshot to file as text or pdf format.");
		cmd.setAdditionalDescription("The default file name is generated from the current coordinates and the default format is plain text. "
				+ "If the file name has extension '.pdf' then save as pdf. To append to an existing file use :code:`>>`. "
				+ "The string :code:`%r` in the file name is replaced with the current coordinates. "
				+ "Examples::\n"
				+ "\n"
				+ "    save mygene.txt~~~~-> Save to mygene.txt as text\n"
				+ "    save >> mygene.txt~-> Append to mygene.txt\n"
				+ "    save~~~~~~~~~~~~~~~-> Save to chrom_start-end.txt as text\n"
				+ "    save .pdf~~~~~~~~~~-> Save to chrom_start-end.pdf as pdf\n"
				+ "    save mygene.%r.pdf~-> Save to mygene.chr1_100-200.pdf as pdf\n"
				+ "\n");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("sessionSave"); cmd.setArgs("filename"); cmd.inSection= Section.GENERAL; 
		cmd.setBriefDescription("Experimental: Save the current settings to file suitable to be reloaded by ASCIIGenome.");
		cmd.setAdditionalDescription("`sessionSave` writes to file a set of commands to reproduce the current "
				+ "settings: tracks, colors, heights etc. It's not meant to be a perfect replica, rather it's a "
				+ "shortcut to avoid re-typing commands. Example::\n"
				+ "\n"
				+ "    sessionSave session.txt\n"
				+ "\n"
				+ "Quit session and reload with::\n"
				+ "\n"
				+ "    ASCIIGenome -x session.txt\n"
				+ "");
		cmdList.add(cmd);
		
		cmd= new CommandHelp();
		cmd.setName("sys"); cmd.setArgs("[-L] command"); cmd.inSection= Section.GENERAL; 
		cmd.setBriefDescription("Execute a system command.");
		cmd.setAdditionalDescription(""
				+ "By default the given :code:`command` is executed as a string passed to "
				+ "Bash as :code:`bash -c string`. With the :code:`-L` option the command is "
				+ "executed literally as it is. Note that with the :code:`-L` option globs "
				+ "are not expanded by Java. Examples::\n"
				+ "\n"
				+ "    sys pwd~~~~~~~~~~~~~~~~~~~~<- Print working directory name\n"
				+ "    sys ls *.bam ~~~~~~~~~~~~~~<- List files ending in .bam\n"
				+ "    sys samtools index aln.bam <- Exec samtools"
				+ "");
		cmdList.add(cmd);
		
		cmd= new CommandHelp();
		cmd.setName("q"); cmd.setArgs(""); cmd.inSection= Section.GENERAL; 
		cmd.setBriefDescription("Quit");
		cmd.setAdditionalDescription("");
		cmdList.add(cmd);

		cmd= new CommandHelp();
		cmd.setName("h"); cmd.setArgs("-h"); cmd.inSection= Section.GENERAL; 
		cmd.setBriefDescription("h and -h show this help.\n"
				+ "For help on commands: `command -h`, e.g. :code:`ylim -h`");
		cmd.setAdditionalDescription("");
		cmdList.add(cmd);
				
		// Make sure ther are no undocumented cmds
		List<String> documented= new ArrayList<String>();
		for(CommandHelp x : cmdList){
			if(documented.contains(x.getName())){
				System.err.println(x.getName() + " already documented!");
				throw new InvalidCommandLineException();
			}
			documented.add(x.getName());
		}
		for(String x : CommandList.cmds()){
			if(!documented.contains(x)){
				System.err.println("Undocumented command: " + x);
				// throw new InvalidCommandLineException();
			}
		}
		
		return cmdList;
			
		}

	protected static List<CommandHelp> getCommandsForSection(Section section) throws InvalidCommandLineException, InvalidColourException{
		List<CommandHelp> cmdList= new ArrayList<CommandHelp>();
		for(CommandHelp x : commandHelpList()){
			if(x.inSection.equals(section)){
				cmdList.add(x);
			}
		}
		return cmdList;
	}
	
	
	/* Known commnds */
	protected static final List<String> cmds(){
		List<String> paramList= new ArrayList<String>();
		paramList.add("q");
		paramList.add("h");
		paramList.add("f");
		paramList.add("b");
		paramList.add("ff");
		paramList.add("bb");
		paramList.add("zi");
		paramList.add("zo");
		paramList.add("extend");
		paramList.add("l");
		paramList.add("r");
		paramList.add("goto");
		paramList.add("INT");
		paramList.add("+");
		paramList.add("-");
		paramList.add("p");
		paramList.add("n");
		paramList.add("next");
		paramList.add("find");
		paramList.add("seqRegex");
		paramList.add("bookmark");
		paramList.add("grep");
		paramList.add("awk");
		paramList.add("gffNameAttr");
		paramList.add(Command.featureDisplayMode.getCmdDescr());
		paramList.add("gap");
		paramList.add("trackHeight");
		paramList.add("colorTrack");
		paramList.add("hideTitle");
		paramList.add("editNames");
		paramList.add("ylim");
		paramList.add("dataCol");
		paramList.add(Command.print.getCmdDescr());
		paramList.add("setGenome");
		paramList.add("showGenome");
		paramList.add("infoTracks");
		paramList.add("addTracks");
		paramList.add("recentlyOpened");
		paramList.add("dropTracks");
		paramList.add("orderTracks");
		paramList.add("posHistory");
		paramList.add("history");
		paramList.add(Command.rpm.getCmdDescr());
		paramList.add("samtools");
		paramList.add(Command.BSseq.getCmdDescr());
		paramList.add("save");
		paramList.add("sessionSave");
		paramList.add("sys");
		paramList.add("setConfig");
	
		return paramList;
	}

	public static String getHelpForCommand(String commandName) throws InvalidColourException {
		try {
			for(CommandHelp x : CommandList.commandHelpList()){
				if(x.getName().equals(commandName)){
					return x.printCommandHelp();
				}
			}
		} catch (InvalidCommandLineException e1) {
			e1.printStackTrace();
		}
		return "";
	}

	private static String toTitleCase(String x){
		x= x.toLowerCase();
		return x.substring(0, 1).toUpperCase() + x.substring(1);
	}
}
