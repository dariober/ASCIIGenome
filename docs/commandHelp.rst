.. _command_reference:

.. This document is autogenerated by CommandList.reStructuredTextHelp().
   Do not edit it here. Edit source code then run tests in CommandListTest.updateReStructuredFile() to recreate this file.

Command reference
=================

This is the documentation for the indvidual commands. The help documented here can be invoked also at the command prompt with `command -h`, for example to get the help for `ylim`::

    ylim -h

Parameters in square brakets are optional and the default argument is indicated by the `=` sign. The syntax `...` indicate that the argument can be repeated multiple times. For example::

    ylim min max [track_regex = .*]...

Means that `ylim` takes two mandatory arguments, `min` and `max`. The optional argument, `track_regex`, defaults to `.*` and can be repated multiple times.


Navigation
----------

goto
++++

:code:`goto chrom[:from[-to]] | chrom [from [to]]`

Go to region `chrom:from-to` or to `chrom:from` or to the start of `chrom`.  The region may be separated by `:` and `-` or by spaces. The character ':' is a shortcut for `goto`. Examples::

    goto chr8:1-1000   # Go to region 1-1000 on chr8
    goto chr8 1 1000   # Use spaces instead
    goto chr8 1-1000   # Same as above
    goto chr8 1 - 1000 # Same as above
    goto chr8 1 1,000  # Comma in numbers is ok
    goto chr8:10       # Go to position 10 on chr8
    goto chr8          # Go to start of chr8
    goto chr8 10 30 50 # Go to chr8:10-50
    :chr8              # Colon ':' shortcut



INT
+++

:code:`INT from [c | to]`

Go to position `from` or to region `from to` on current chromosome. If a list of integers is given, the first and last are taken as *from* and *to*. This is handy to copy and paste intervals from the ruler above the prompt.

* :code:`c` set the position of *from* at the center of the screen. 

* :code:`to` set the new window in the region delimited by *from* and *to*. 

Examples::

    10                   -> Will jump to position 10 
    10 1000              -> Go to region 10-1000 
    10 250 500 750 1000  -> Same as above again
    750 c                -> Put the position 750 right in the middle
    750c                 -> Same as '750 c' space is optional



PERCENT
+++++++

:code:`PERCENT from [c | to]`

Zoom into the current window delimited by given PERCENT of screen. PERCENT is a number in the range 0-1 mapping to the given percent of the current genomic window. Similar to the `:code:INT` command, one number moves the genomic window to the position located at PERCENT and two numbers will zoom into the region PERCENT-PERCENT.
This command is useful to quickly focus an a feature of interest, such as a ChIP-Seq peak or a variant.

* :code:`c` set the position of *from* at the center of the screen. 

* :code:`to` set the new window in the region delimited by *from* and *to*. 

Examples::

    0.25      -> Jump to position at 25% of current screen.
    .25       -> Same as above.
    .25 .75   -> Zoom into the interval between 25-75% of current screen.
    .25 c     -> Put the position at 25% of current screen right in the middle.
    .25c      -> Same as '.25 c' (space is optional).



plus +
++++++

:code:`+ INT [k|m]`

Move forward by `INT` bases. Suffix K/M recognized.  Suffixes k (kilo) and M (mega) are expanded to x1000 and x1,000,000. Examples::

    +2m
    +10k
    +10.5k



minus -
+++++++

:code:`- INT [k|m]`

Move backwards by INT bases. Suffix K/M recognized.  Suffixes k (kilo) and M (mega) are expanded to x1000 and x1,000,000.
Examples::

    -100
    -10k
    -10.5m



f - forward
+++++++++++

:code:`f [NUM=0.1]`

Move forward NUM times the size of the current window, 1/10 by default. 

b - backward
++++++++++++

:code:`b [NUM=0.1]`

Move backward NUM times the size of the current window, 1/10 by default 

ff
++

:code:`ff`

Move forward by 1/2 of a window. A shortcut for `f 0.5` 

bb
++

:code:`bb`

Move backward by 1/2 of a window. A shortcut for `b 0.5` 

]
+

:code:`] INT=1`

Move forward by INT screen columns Same as **[** but moves forward. See **[** for details

[
+

:code:`[ INT=1`

Move backwards by INT screen columns. The **[** character can be repeated and each **[** will move by one column. Examples::

    [   -> Move one screen column
    [[[ -> Move three columns
       [ 3 -> Same as above
       [3  -> Same as above (space is optional)



zi
++

:code:`zi [INT = 1]`

Zoom in INT times. Each zoom halves the window size.  To zoom quickly use INT= 5 or 10 e.g. `zi 10`

zo
++

:code:`zo [INT = 1]`

Zoom out INT times. Each zoom doubles the window size.  To zoom quickly use INT= 5 or 10 e.g. `zo 10`

extend
++++++

:code:`extend [mid|window] [INT left] [INT right]`

Extend the current window by `INT` bases left and right.
 
* :code:`window` (default): Extend the current window left and right by `INT` bases

* :code:`mid` The new window is given by the midpoint of the current window plus and minus `INT` bases left and right.

If only one INT is given it is applied to both left and right. Negative INTs will shrink instead of extend the window.

l - left
++++++++

:code:`l`

Go to the Left half of the current window.  Alternate the left and right command to quickly focus on a point of interest. 

r - right
+++++++++

:code:`r`

Go to the Right half of the current window.  Alternate the left and right command to quickly focus on a point of interest. 

p
+

:code:`p`

Go to the previous visited position.  Similar to the back and forward arrows of an Internet browser.

n
+

:code:`n`

Go to the next visited position.  Similar to the back and forward arrows of an Internet browser.

next
++++

:code:`next [-back] [-start] [-c] [-zo INT=5] [track]`

Move to the next feature not overlapping the current coordinates.  By default `next` centers the window on the next feature and zooms out.

* :code:`-back` Search backwards. I.e. move to next feature on the left of the current position.

* :code:`-start` Set the window right at the start of the feature, without centering and zooming out.

* :code:`-c` Set the window so that the start of the feature is right in the middle of the window. Useful to browse small features such as SNV and indels.

* :code:`-zo INT` Zoom out INT times after having found the next feature.   Ignored if the `-start` flag is set. If <= 0 the window spans exactly the feature coordinates.   Default 5.

* :code:`track` Track to search for next feature. Default to the first annotation track found.

`next` starts searching immediately after the current window and loops thourgh each chromosome until a feature is found.

Find
----

find
++++

:code:`find [-all] [-c] [-F] regex [track]`

Find the first record in `track` containing `regex`. The search for `regex` starts from the *end* of the current window (so the current window is not searched) and moves forward on the current chromosome. At the end  of the current chromosome move to the next chromosomes and then restart at  the start of the initial one. The search stops at the first match found. If `track` is omitted the first interval track found is searched.

* :code:`-all`: Return the region containing **all** the regex matches.

* :code:`-c` Match in CASE SENSITIVE mode. Default is case insensitive (changed in v1.12).

* :code:`-F`: Interpret `regex` as a fixed, literal string instead of as a regex.

Examples::

    find -all ACTB genes.gtf -> Find all the matches of ACTB. Case ignored
    find -c 'ACTB gene'      -> Find the first match of 'ACTB gene'. Case sensitive

Use single quotes to define patterns containing spaces.

seqRegex
++++++++

:code:`seqRegex [-iupac] [-c] [regex]`

Find regex in reference sequence and show matches as an additional track.  Options:

* :code:`regex` Regex to search. If missing the seq regex track is removed.

* :code:`-iupac` Enable the interpretation of the IUPAC ambiguity code. NB: This option simply converts IUPAC chracters to the corresponding regex.

* :code:`-c` Enable case-sensitive matching. Default is to ignore case.

Examples::

    seqRegex ACTG        -> Case insensitive, actg matched
    seqRegex -c ACTG     -> Case sensitive, will not match actg
    seqRegex -iupac ARYG -> Interpret (converts) R as [AG] and Y as [CT]
    seqRegex             -> Disable regex matching track

To save matches to file, see the `print` command. This command is ignored if the reference fasta sequence is missing.

bookmark
++++++++

:code:`bookmark [-d] [-n name] [-print] [> file] [chrom:from-to]`

Creates a track to save positions of interest. Without arguments, add the current position to the bookmark track. Options:

* :code:`chrom:from-to` Bookmark this region. If chrom is omitted, use the current chromosome.

* :code:`-d` Remove the bookmark at coordinates [chrom:from-to].

* :code:`-n name` Use name for this new bookmark.

* :code:`-print` prints to screen the list of current bookmarks.

* :code:`> file` saves the bookmark track to file.

Examples::

    bookmark              -> Add the current window to bookmarks.
    bookmark 100          -> Bookmark position 100 on current chrom
    bookmark 100-110      -> Bookmark position 100-110 on current chrom
    bookmark chr1:100     -> Bookmark position chr1:100
    bookmark -d chr1:100  -> Delete bookmark at chr1:100
    bookmark > books.txt  -> Save to file books.txt
    bookmark -print       -> Show table of bookmarks



Display
-------

grep
++++

:code:`grep [-i = .*] [-e = ''] [-c] [-F] [-v] [track_regex = .*]...`

Similar to grep command, filter for features including or excluding patterns. Options:

* :code:`-i regex`  Show features matching this regex.

* :code:`-e regex` Exclude features matching this regex.

* :code:`-c` Match in CASE SENSITIVE mode. Default is case insensitive (changed in v1.12).

* :code:`-F` Interpret `regex` in `-i` and `-e` as a fixed, literal string instead of as a regex.

* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

* :code:`track_regex` Apply to tracks matched by `track_regex`.

*NOTES*

* Use *single quotes* to delimit patterns containing spaces e.g. :code:`-i 'ACTB gene'`

Regex `-i` and `-e` are applied to the raw lines as read from source file and it is applied only to annotation tracks (GFF, BED, VCF, etc). For example::

    grep -i RNA -e mRNA gtf gff

Will show the rows containing 'RNA' but will hide those containing 'mRNA', applies to tracks whose name matches 'gtf' or 'gff'.
With no arguments reset to default: :code:`grep -i .* -e ^$ .*` which means show everything, hide nothing, apply to all tracks.

awk
+++

:code:`awk [-off ...] [-F sep_re] [-v VAR=var] [-V] '<script>' [track_regex = .*]...`

Advanced feature filtering using awk syntax. awk offers finer control then :code:`grep` to filter records in tabular format.

Awk is column oriented. Awk splits each line into a list using a given regular expression as delimiter (default delimiter is the TAB character). To access an item, i.e. a column, use the syntax :code:`$n` where *n* is the position of the item in the list, e.g. :code:`$3` will access the third field (i.e. 3rd column). The variable :code:`$0` holds the entire line as single string.

Awk understands numbers and mathematical operators. With awk you can filter records by numeric values in one or more fields since numbers are handled as such. You can also perform arithmetic operations and filter on the results.

*OPTIONS*

* :code:`-off track_re ...`  Turn off awk filtering for tracks captured by the list of regexes.

* :code:`-F <sep_re>` Use regular expression <sep_re> as column separator. Default is '\t' (tab). To separate on white space use e.g. '\b' (backspace) or '\s' (any white space). Do not use ' '. 

* :code:`-v VAR=var` Pass to awk script the variable VAR with value var. Can be repeated.

* :code:`script` The awk script to be executed. Must wrapped in single quotes.

* :code:`-V` Invert selection: apply changes to the tracks not selected by list of track_regex

**ADDITIONAL FEATURES**

Function :code:`get(...)` can indistinctly be applied to GTF, GFF, SAM records and to INFO and FORMAT fields in VCF files. Double quoting around <tag> is optional.

* :code:`get(tag)` on **GTF**

Return the value of tag attribute.

* :code:`get(tag, [value_idx])` on **GFF**

Return the value of tag attribute. If the attribute contains multiple values return the value at index value_idx (1-based). If value_idx is missing (as default), return the entire value as it is.

* :code:`get(tag)` on **SAM**

Return the value of the given sam tag.

* :code:`get(tag, [value_index])` on **VCF**

Return the value of the given **INFO** tag. If the tag contains multiple values, optionally return only the value at index *value_index*. If necessary, prepend 'INFO/' to tag to disambiguate it from FORMAT tags or if the header does not contain this tag. If the tag is of type 'Flag', return 1 if present, 0 otherwise.

* :code:`get(tag, [sample_idx], [value_idx])` on **VCF**

Return the value of the **FORMAT** tag for sample index *sample_idx* (default to 1, first sample). If the tag contains multiple values, optionally return the value at index *value_idx*. If necessary, prepend 'FMT/' to tag to disambiguate it from INFO tags or if the header does not contain this tag.  If the tag is of type 'Flag', return 1 if present, 0 otherwise.

* Column headers

The following variables are replaced by the appropriate column indexes, so they can be used to easily select columns. Make sure the track types are selected to be compatible with the headers.

- bam tracks::

    $QNAME, $FLAG, $RNAME, $POS, $MAPQ, $CIGAR, $RNEXT, $PNEXT, $TLEN, $SEQ, $QUAL

- vcf tracks::

    $CHROM, $POS, $ID, $REF, $ALT, $QUAL, $FILTER, $INFO, $FORMAT

- gtf and gff tracks::

    $SEQNAME, $SOURCE, $FEATURE, $START, $END, $SCORE, $STRAND, $FRAME, $ATTRIBUTE

- bed tracks::

    $CHROM, $START, $END, $NAME, $SCORE, $STRAND, $THICKSTART, $THICKEND, $RGB, $BLOCKCOUNT, $BLOCKSIZES, $BLOCKSTARTS

*EXAMPLES*

Note the use of single quotes to wrap the actual script and the use of double quotes inside the script.

* Filter for lines where the 4th column is between 10 and 100. Apply only to tracks matching '.gtf' or '.gff'::

    awk '$4 > 10 && $4 <= 100' .gtf .gff

* Filter for either perfect a match or by matching a regex on 3rd column. Apply to all tracks. The second example matches regex on the entire line (similar to grep), The third example also requires features to be on + strand::

    awk '$3 == "exon" || $3 \  ".*_codon"'
    
    awk '$0 \  ".*_codon"'
    
    awk '($3 == "exon" || $3 \  ".*_codon") && $7 == "+"'

* Filter for features size (assuming bed format) and for values after log10 transformation. For log10 we need to change base using ln(x)/ln(10)::

    awk '($3 - $2) > 1000 && (log($4)/log(10)) < 3.5'

* Remove awk filter for tracks captured by .gff and .gtf::

    awk -off .gtf .gff

* Return bam records where NM tag (edit distance) is > 0. Double quotes around NM are optional::

    awk 'get(NM) > 0' .bam

* Filter vcf records by FORMAT tag. Suppose tag AD in the *second* sample is :code:`63,7`::

    awk 'get(AD, 2) ...' my.vcf      # get() returns string '63,7'
    awk 'get(AD, 2, 1) ...' my.vcf   # get() returns 63
    awk 'get(AD, 2, 2) ...' my.vcf   # get() returns 7
    awk 'get(FMT/AD, 2) ...' my.vcf  # If AD is also in INFO or missing in header

* Using header variables::

    awk '$FEATURE \  "CDS" && $START > 1234' my.gff

With no args, turn off awk for all tracks.

*NOTES & LIMITATIONS*

* This is a java implementation of awk and it is independent on whether awk is on the local system. It should behave very similar to UNIX awk and therefore it has lots of functionalities. In fact, awk is a programming language in itself, search Google for more. The original code is from https://github.com/hoijui/Jawk

* Use awk only to filter features, do not use it to edit them. If features are changed by the awk script than nothing will be retained. This is because the awk command first collects the output from awk, then it matches the features in the current window with those collected from awk.

* Each line is processed independently of the others as a separate awk execution. This means that you cannot filter one line on the bases of previous or following lines.

* This awk is slow, about x5-10 times slower than UNIX awk. For few thousand records the slowdown should be acceptable. Other things being equal, use `grep` instead.

* The default delimiter is TAB not any white space as in UNIX awk.

* An invalid script throws an ugly stack trace to stderr. To be fixed.

featureColor
++++++++++++

:code:`featureColor [-r/-R expression color] [-v] [track_regex = .*]...`

Set colour for features captured by expression.  This command affects interval feature tracks (bed, gff, vcf, etc) and overrides the default color for the lines captured by the expression. Expression is a regex or an awk script (autodetermined). It is useful to highlight features containg a string of interest, such as 'CDS' in gff files, or features where a numeric field satisfy a filter.

Options:

:code:`-r <expression> <color>` Features matching :code:`expression` will have color :code:`color`. The expression is interpreted as regex or as an awk script and it is applied to the raw lines as read from file. This option takes exactly two arguments and can be given zero or more times.

:code:`-R <expression> <color>` Same as :code:`-r` but sets color for features NOT matched by regex.

:code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

:code:`[track_regex]` Apply to tracks captured by this list of regexes.

Example::

    featureColor -r CDS plum2 -r exon grey
    featureColor bed         -> Reset to default the track matching 'bed'
       featureColor -R CDS grey -> Grey all features except those matching CDS
    
    Color blue where 9th field is > 3; color red where 9th is > 6
    featureColor -r '$9 > 3' blue -r '$9 > 6' red

Colors can be specified by name, name prefix, or integer in range 0-255. Available colours:`here <http://jonasjacek.github.io/colors/>`_             

Example::

    colorTrack cyan1 ts.*gtf ts.*bam 
    colorTrack 40                   <- By INT
    colorTrack darkv                <- Same as darkviolet



hideTitle
+++++++++

:code:`hideTitle [-on | -off] [-v] [track_regex = .*]...`

Set the display of the title line matched by track_regex.  Without argument -on or -off toggle between the two modes for all tracks matched by the list of regexes.

:code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex


genotype
++++++++

:code:`genotype [-n 10] [-s .*] [-r pattern rplc] [-f expr] [-v] [track_regex = .*]...`

Customise the genotype rows printed under the VCF tracks.  

:code:`-n` Display up to this many samples (rows). -1 for no limit.

:code:`-s` Select samples matching this regex.

:code:`-r` Edit sample names to replace <pattern> with <replacement>. Names are edited only for display. To completely hide names replace with empty string :code:`-r .* ''`. To restore original names use a regex matching nothing e.g. '^$'

:code:`-f` Filter samples using an expression in javascript syntax. See below for details.

:code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

FILTER EXPRESSION

Samples can be filtered by applying arbitrary expressions to the VCF records. The VCF fields of a sample are accessed using the syntax :code:`{TAG}`.

TAG is one of the fixed fields: CHROM, POS, ID, REF, ALT, QUAL, FILTER, or one of the INFO or FORMAT tags. In case of ambiguity, the prefix 'INFO/' or 'FMT/' should be used to identify the target tag (e.g. :code:`{FMT/ID}` will access the ID field in FORMAT rather than the ID in the header).

The value(s) in a TAG are converted to the appropriate data type (Integer, String, etc). Tags holding more than one value are returned as arrays whose individual values should be accessed using the syntax :code:`[index]`. E.g. :code:`{ALT}[0]` will access the first alternate allele.

Note that the ALT and FILTER fields are always arrays, even if only one allele is present.

After substitution of the :code:`{TAG}` placeholders with the actual values, the expression string is evaluated as a javascript script so any valid JS code is allowed including the common operators: :code:`> < == != && ||`.

Importantly, the result of the expression must be a boolean, i.e. it must evaluate to true or false.

For each sample, the expression is evaluated for each VCF record in the current window and if ANY record returns *true*, the sample is filtered-in. To apply the filter to specific records either include only those records using e.g. commands :code:`grep` or :code:`awk` or make the expression more selective, e.g. by including the POS field.

As elsewhere in ASCIIGenome, if the argument (expression) contains spaces it must be enclosed in single quotes and single quotes inside the expression must be escaped. To remove the expression filter pass a blank string as argument :code:`-f ' '` (note the white space between single quotes).

The following tags can be used to filter on the genotype. When substituted, they evaluate to true according to the sample genotype. Testing the :code:`{GT}` tag, e.g. :code:`{GT} == "0/1"`, achieves a similar result and gives more control but using these tags is less error prone:

* :code:`{HOM}` genotype is homozygote.

* :code:`{HET}` genotype is heterozygote.

* :code:`{HOM_REF}` genotype is homozygote reference.

* :code:`{HOM_VAR}` homozygote for an ALT allele.

* :code:`{HET_NON_REF}` heterozygote and all alleles are non-reference.

* :code:`{CALLED}` at least one allele is not a missing value ('.' in vcf).

* :code:`{NO_CALL}` No allele is called (e.g. it appears as ./. in vcf).

* :code:`{MIXED}` genotype is comprised of both calls and no-calls.

Examples of filters::

    genotype -f '{DP} > 30' -> Display samples having DP > 30
    genotype -f '{DP} > 30 && {ID} == "rs99"' -> Select also for ID
    genotype -f '{FMT/XA} > 30 && {INFO/XA} == "foo"' -> Disambiguate tags
    genotype -f '{ALT}[0] == "C"'  -> Access the first ALT allele
    genotype -f '{HOM_REF} == false' -> Discard if homozygote ref.



editNames
+++++++++

:code:`editNames [-t] [-v] <pattern> <replacement> [track_re=.*]...`

Edit track names by substituting regex pattern with replacement. Pattern and replacement are required arguments, the default regex for track is '.*' (i.e. all tracks).

* :code:`-t` (test) flag shows what renaming would be done without actually editing the names.

* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

Use '' (empty string in single quotes) to replace pattern with nothing. Examples: Given track names 'fk123_hela.bam#1' and 'fk123_hela.bed#2'::

    editNames fk123_ ''       -> hela.bam#1, hela.bed#2
    editNames fk123_ '' bam   -> hela.bam#1, fk123_hela.bed#2
    editNames _ ' '           -> fk123 hela.bam#1,  fk123 hela.bed#2
    editNames ^.*# cells      -> cells#1, cells#2
    editNames ^ xx_           -> xx_fk123_hela.bam#1, xx_fk123_hela.bed#2 (add prefix)


dataCol
+++++++

:code:`dataCol [-v] [index = 4] [track_regex = .*]...`

Select data column for bedgraph tracks containing regex.  First column has index 1. This command applies only to tracks of type bedgraph.

:code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

For example, use column 5 on tracks containing #1 and #3::
 
    dataCol 5 #1 #3



print
+++++

:code:`print [-n INT] [-full] [-off] [-round INT] [-hl re] [-esf] [-v] [-sys CMD] [track_regex = .*]... [>|>> file]`

Print lines for the tracks matched by `track_regex`.  Useful to show exactly what features are present in the current window. Features are filtered in/out according to the :code:`grep` command. Options:

* :code:`track_regex` Apply to tracks matched by one or more of these regexes.

* :code:`-n INT=10` Print up to this many lines, default 10. No limit if < 0.

* :code:`-clip` Clip lines longer than the screen width. This is the default.

* :code:`-full` Wrap lines longer than the screen width.

* :code:`-round INT` Round numbers to this many decimal places. What constitutes a number is inferred from context. Default 3, do not round if < 0.

* :code:`-hl regex` Highlight substrings matching regex. If regex matches a FORMAT tag in a VCF record, highlight the tag itself and also the sample values corresponding to that tag. Alternatively, regex may be a comma separated list of column indexes to highlight. Indexes are recognized by the $ prefix. E.g. :code:`-hl '$1, $3, $10'` will highlight columns 1, 3, 10.

* :code:`-esf` Explain SAM Flag. Add to SAM flag an abbreviated description.

* :code:`-off` Turn off printing.

* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

* :code:`-sys` Parse the raw output with the given system command(s). Use :code:`-sys null` to turn off the system commands. These commands are executed by :code:`bash` so bash is expected to be available on the system. The commands should read from stdin and write to stdout, this is usually the case for Unix commands like :code:`cut`, :code:`sort`, etc. The command string must be enclosed in single quotes, single quotes inside the string can be escaped as \' (backslash-quote)

* :code:`>` and :code:`>>` Write output to `file`. `>` overwrites and `>>` appends to existing file. The %r variable in the filename is expanded to the current genomic coordinates. Writing to file overrides options -n and -off, lines are written in full without limit.

Without options toggle tracks between OFF and CLIP mode.

Examples::

    print                        -> Print all tracks, same as `print .*`
    print -off                   -> Turn off printing for all tracks
    print genes.bed >> genes.txt -> Append features in track(s) 'genes.bed' to file
    print -sys 'cut 1-5 | sort'  -> Select columns with `cut` and then sort
    print -sys null              -> Turn off the execution of sysy commands


Alignments
----------

readsAsPairs
++++++++++++

:code:`readsAsPairs [-on | -off] [-v] [track_regex = .*]...`

Show SAM records as pairs.
 If set, properly paired reads in the current window are showed joined up by tildes.

* :code:`-on|-off` Turn on/off the pairing mode. Or toggle between the two modes if none of these flags is set.

* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

* :code:`[track_regex = .*]...` Apply to read tracks captured by these regexes.


filterVariantReads
++++++++++++++++++

:code:`filterVariantReads [-r from/to] [-all] [-v] [track_regex = .*]...`

Filter reads containing a variant in the given interval.
 :code:`filterVariantReads` selects for reads where the read sequence mismatches with the reference sequence in the given interval on the current chromosome. This command is useful to inspect reads supporting a putative alternate allele at a variant site.

NOTES

* :code:`filterVariantReads` requires a reference fasta sequence to be set, e.g. via the command line option :code:`-fa <ref.fa>` or with command :code:`setGenome`.

* The CIGAR string determines a mismatch between read and reference. Consequently, there may be an inconsistency between variant positions in reads and positions in a VCF file if some normalization or indel realignment has been performed by the variant caller that generated the VCF. In such cases consider enlarging the target interval.

* The position (POS) of deletions in VCF files refer to the first non-deleted base on the reference. Therefore, the interval to :code:`-r` should be POS+1 to filter for reads supporting a deletion (but see also the previous point).

OPTIONS

* :code:`-r region` Select reads mismatching in this interval. *region* can be given as: a single position, a position plus and/or minus an offset, an interval. See examples.

* :code:`-all` Return *all* reads intersecting the :code:`-r` interval, not just the variant ones.

* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

* :code:`[track_regex = .*]...` Apply to read tracks captured by these regexes.

EXAMPLES::

    filterVariantReads -r 1000+10   <- From 1000 to 1010
    filterVariantReads -r 1000-10   <- From 990 to 1000
    filterVariantReads -r 1000+/-10 <- From 990 to 1010
    filterVariantReads -r 1000:1100 <- From 1000 to 1100
    filterVariantReads -r 1000 vars.*vcf <- Apply to tracks captured by `vars.*vcf`
    filterVariantReads              <- Remove filter for all tracks


rpm
+++

:code:`rpm [-on | -off] [-v] [track_regex = .*]`

Set display to reads per million for BAM and TDF files.
 
* :code:`-on | -off` Set mode on/off. Without arguments toggle between on and off.

* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

* :code:`track_regex` List of regexes to capture target tracks.

samtools
++++++++

:code:`samtools [-f INT=0] [-F INT=4] [-q INT=0] [-v] [track_re = .*] ...`

Apply samtools filters to alignment tracks captured by the list of track regexes. Useful for stranded RNA-Seq and BS-Seq: bit flag 4096 is selects reads mapping to TOP STRAND.

* :code:`-F` Filter out flags with these bits set. NB: 4 is always set.

* :code:`-f` Require alignment to have these bits sets.

* :code:`-q` Require alignments to have MAPQ >= than this.

* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

Examples::

    samtools -q 10           -> Set mapq for all tracks. -f and -F reset to default
    samtools -F 1024 foo bar -> Set -F for all track containing re foo or bar
    samtools -f 4096         -> Select TOP STRAND reads
    samtools -F 4096         -> Select BOTTOM STRAND reads
    samtools                 -> Reset all to default.


BSseq
+++++

:code:`BSseq [-on | -off] [-v] [track_regex = .*]...`

Set bisulfite mode for read tracks matched by regex. In bisulfite mode, the characters M and m mark methylated bases (i.e. unconverted C to T) and U and u are used for unmethylated bases (i.e. C converted to T). Upper case is used for reads on  forward strand, small case for reverse.

* :code:`-on | -off` Set mode. Without arguments toggle between on and off.

* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

* :code:`track_regex` List of regexes to capture target tracks.

Ignored without reference fasta sequence.

General
-------

setGenome
+++++++++

:code:`setGenome fasta|bam|genome`

Set genome and reference sequence. The genome, i.e. the list of contig names and sizes, can be extracted from the fasta reference, from a bam file or from a genome identifier (e.g. hg19). If a fasta file is used also the reference sequence becomes available.

Without arguments, set the genome using the last opened fasta file, if any and if compatible with the current tracks.

setConfig
+++++++++

:code:`setConfig <file|tag> | <key> <value>`

Set configuration arguments. 

If only one argument is given then the entire settings are replaced. Configuration can be set with one of the built-in themes: 'black_on_white', 'white_on_black', 'metal'. Alternatively, configuration can be read from file. For examples files see 
https://github.com/dariober/ASCIIGenome/blob/master/resources/config/

If two arguments are given, they are taken as a key/value pair to reset.

Examples::

    setConfig metal
    setConfig /path/to/mytheme.conf
       setConfig max_reads_in_stack 20000 <- Reset this param only

Parameters and current settings::

    background                         231   # Background colour                                          
    foreground                         0     # Foreground colour                                          
    seq_a                              12    # Colour for nucleotide A                                    
    seq_c                              9     # Colour for nucleotide C                                    
    seq_g                              2     # Colour for nucleotide G                                    
    seq_t                              11    # Colour for nucleotide T                                    
    seq_other                          0     # Colour for any other nucleotide                            
    shade_low_mapq                     249   # Colour for shading reads wit low MAPQ                      
    methylated_foreground              231   # Foreground colour for methylated C                         
    unmethylated_foreground            231   # Foreground colour for unmethylated C                       
    methylated_background              9     # Background colour for methylated C                         
    unmethylated_background            12    # Background colour for unmethylated C                       
    title_colour                       0     # Default Colour for titles                                  
    feature_background_positive_strand 147   # Colour for features on forward strand                      
    feature_background_negative_strand 224   # Colour for features on reverse strand                      
    feature_background_no_strand       249   # Colour for features without strand information             
    footer                             12    # Colour for footer line                                     
    chrom_ideogram                     0     # Colour for chromosome ideogram                             
    ruler                              0     # Colour for ruler                                           
    max_reads_in_stack                 2000  # Max number of reads to accumulate when showing read tracks 
    shade_baseq                        13    # Shade read base when quality is below this threshold       
    shade_structural_variant           33    # Background colour for reads suggesting structural variation
    highlight_mid_char                 true  # Highlight mid-character in read tracks?                    
    nucs_as_letters                    true  # Show read nucleotides as letters at single base resolution?
    show_soft_clip                     false # NOT IN USE YET - Show soft clipped bases in read tracks?   

explainSamFlag
++++++++++++++

:code:`explainSamFlag INT [INT ...]`

Explain the list of bitwise SAM flags.  Decode one or more sam flags to human readable form and print them as a table. Similar to https://broadinstitute.github.io/picard/explain-flags.html

show
++++

:code:`show <arg>`

Show or set features to display.  The argument :code:`arg` takes the following choices:

* :code:`genome`: Show chromosomes and their sizes as barplot provided a genome file is available.

* :code:`trackInfo`: Show information on tracks.

* :code:`gruler`: Toggle the display of the genomic coordinates as ruler.

* :code:`pctRuler`: Toggle the display of the column number of the terminal (useful for navigation within the current genomic window).

:code:`arg` can be just a prefix of the argument name, e.g. :code:`show ge` will be recognized as :code:`show genome`.

recentlyOpened
++++++++++++++

:code:`recentlyOpened [-grep = .*]`

List recently opened files.  Files are listed with their absolute path.

* :code:`-n INT` Return only the last INT files.

* :code:`-grep <pattern>` Filter for files (strings) matching pattern. Use single quotes to define patterns containing spaces, e.g. :code:`-grep 'goto chr1'`.

open
++++

:code:`open [files | URLs | indexes]...`

Add tracks from local or remote files.  The list of files to open can be a list of file names or URLs. For local files, glob characters (wildcard) are expanded as in Bash (but note that currently globs in directory names are not expanded.)

Alternatively, the files to open can be given as numeric indexes of recently opened files (see command :code:`recentlyOpened`). The last opened file has index 1, the second last 2, etc.

Examples::

    open peaks.bed genes.*.gtf        <- Note use of wildecard
    open http://remote/host/peaks.bed <- From URL
    open 1 2 3                        <- The three most recent files


reload
++++++

:code:`reload [track_regex = .*]...`

Reload track files.  *reload* is useful when an input track file is edited by external actions and you want to reload it in the current session. This is easier than dropping and re-opening tracks with *dropTracks ... && open ...* since track formattings and filters are preserved.

A track is dropped if it cannot be reloaded, for example when the sequence disctionary has become incompatible with the current one.

Examples::

    reload       <- reload all tracks
    reload .bam  <- reload files matching '.bam'

dropTracks
++++++++++

:code:`dropTracks [-t] [-v] track_regex [track_regex]...`

Drop tracks matching any of the listed regexes. * :code:`-t` (test) flag only shows which tracks would be removed but do not remove them.

* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

Examples::

    dropTracks bam


orderTracks
+++++++++++

:code:`orderTracks [track_regex]...`

Reorder tracks according to the list of regexes or sort by name. Not all the tracks need to be listed, the missing ones follow the listed ones in unchanged order. Without arguments sort track by tag name.
For example, given the track list: `[hela.bam#1, hela.bed#2, hek.bam#3, hek.bed#4]`::

    orderTracks #2 #1   -> [hela.bed#2, hela.bam#1, hek.bam#3, hek.bed#4]
    orderTracks bam bed -> [hela.bam#1, hek.bam#3, hela.bed#2, hek.bed#4]
    orderTracks . bam  -> 'bam' tracks go last
    orderTracks         -> name sort [hela.bam#1, hela.bed#2, hek.bam#3, hek.bed#4]


posHistory
++++++++++

:code:`posHistory [-n INT=10]`

List the visited positions. Recorded positions include the current and the previous sessions of ASCIIGenome.

:code:`-n INT` Show only the last INT positions. Show all if <= 0.

history
+++++++

:code:`history [-n INT] [-grep = .*]`

List the executed commands.  Commands executed in previous sessions of ASCIIGenome are in \ /.asciigenome_history

* :code:`-n INT` Return only the last INT commands.

* :code:`-grep <pattern>` Filter for commands (strings) matching pattern. Use single quotes to define patterns containing spaces, e.g. :code:`-grep 'goto chr1'`

save
++++

:code:`save [>>] [filename = chrom_start_end.txt']`

Save screenshot to file as text or pdf format. The default file name is generated from the current coordinates and the default format is plain text. If the file name has extension '.pdf' then save as pdf. To append to an existing file use :code:`>>`. The string :code:`%r` in the file name is replaced with the current coordinates. Examples::

    save mygene.txt    -> Save to mygene.txt as text
    save >> mygene.txt -> Append to mygene.txt
    save               -> Save to chrom_start-end.txt as text
    save .pdf          -> Save to chrom_start-end.pdf as pdf
    save mygene.%r.pdf -> Save to mygene.chr1_100-200.pdf as pdf



sys
+++

:code:`sys [-L] command`

Execute a system command. By default the given :code:`command` is executed as a string passed to Bash as :code:`bash -c string`. With the :code:`-L` option the command is executed literally as it is. Note that with the :code:`-L` option globs are not expanded by Java. Examples::

    sys pwd                          <- Print working directory name
    sys ls *.bam                     <- List files ending in .bam
    sys bcftools view -h vars.vcf.gz <- Print vcf header


q
+

:code:`q`

Quit 

h
+

:code:`h`

:code:`help`, :code:`h`, :code:`-h`, and :code:`?` show this help.
For help on individual commands use one of::

    command -h
    ?command
    help command

e.g. `ylim -h` 


