.. _command_reference:

.. This document is autogenerated by CommandList.reStructuredTextHelp().
   Do not edit it here. Edit source code then run tests in CommandListTest.updateReStructuredFile() to recreate this file.

Command reference
=================

This is the documentation for the indvidual commands. The help documented here can be invoked also at the command prompt with `command -h`, for example to get the help for `ylim`::

    ylim -h

Parameters in square brakets are optional and the default argument is indicated by the `=` sign. The syntax `...` indicate that the argument can be repeated multiple times. For example::

    ylim min max [track_regex = .*]...

Means that `ylim` takes two mandatory arguments, `min` and `max`. The optional argument, `track_regex`, defaults to `.*` and can be repated multiple times.


Navigation
----------

goto
++++

:code:`goto chrom:[from]-[to]`

Go to region `chrom:from-to` or to `chrom:from` or to the start of `chrom`.  The character ':' is a shortcut for `goto`. Examples::

    goto chr8:1-1000  ## Go to interval 1-1000 on chr8
    goto chr8:10      ## Go to position 10 on chr8
    goto chr8         ## Go to start of chr8

Or the same with::

    :chr8:1-1000 
    :chr8:10 
    :chr8


INT
+++

:code:`INT [INT]`

Go to position `INT` or to region `INT INT` on current chromosome.  Allowed is the hyphenated format  separating the two positions. If a list of integers is given, the first and last are taken as *from* and *to*. This is handy to copy and paste intervals from the ruler above the prompt. 
Examples::

    10                   -> Will jump to position 10 
    10 1000              -> Go to region 10-1000 
    10-1000              -> Same as above
    10 250 500 750 1000  -> Same as above again



plus +
++++++

:code:`+ INT [k|m]`

Move forward by `INT` bases. Suffix K/M recognized.  Suffixes k (kilo) and M (mega) are expanded to x1000 and x1,000,000. Examples::

    +2m
    +10k
    +10.5k



minus -
+++++++

:code:`- INT [k|m]`

Move backwards by INT bases. Suffix K/M recognized.  Suffixes k (kilo) and M (mega) are expanded to x1000 and x1,000,000.
Examples::

    -100
    -10k
    -10.5m



f - forward
+++++++++++

:code:`f [NUM=0.1]`

Move forward NUM times the size of the current window, 1/10 by default. 

b - backward
++++++++++++

:code:`b [NUM=0.1]`

Move backward NUM times the size of the current window, 1/10 by default 

ff
++

:code:`ff`

Move forward by 1/2 of a window. A shortcut for `f 0.5` 

bb
++

:code:`bb`

Move backward by 1/2 of a window. A shortcut for `b 0.5` 

zi
++

:code:`zi [INT = 1]`

Zoom in INT times. Each zoom halves the window size.  To zoom quickly use INT= 5 or 10 e.g. `zi 10`

zo
++

:code:`zo [INT = 1]`

Zoom out INT times. Each zoom doubles the window size.  To zoom quickly use INT= 5 or 10 e.g. `zo 10`

extend
++++++

:code:`extend [mid|window] [INT left] [INT right]`

Extend the current window by `INT` bases left and right.
 
* :code:`window` (default): Extend the current window left and right by `INT` bases

* :code:`mid` The new window is given by the midpoint of the current window plus and minus `INT` bases left and right.

If only one INT is given it is applied to both left and right. Negative INTs will shrink instead of extend the window.

l - left
++++++++

:code:`l`

Go to the Left half of the current window.  Alternate the left and right command to quickly focus on a point of interest. 

r - right
+++++++++

:code:`r`

Go to the Right half of the current window.  Alternate the left and right command to quickly focus on a point of interest. 

p
+

:code:`p`

Go to the previous visited position.  Similar to the back and forward arrows of an Internet browser.

n
+

:code:`n`

Go to the next visited position.  Similar to the back and forward arrows of an Internet browser.

next
++++

:code:`next [-back] [-start] [-zo INT=5] [track]`

Move to the next feature not overlapping the current coordinates.  By default `next` centers the window on the next feature and zooms out.

* :code:`-back` Search backwards. I.e. move to next feature on the left of the current position.

* :code:`-start` Sets the window right at the start of the feature, without centering and zooming out.

* :code:`-zo INT` Zoom out INT times after having found the next feature.   Ignored if the `-start` flag is set. If <= 0 the window spans exactly the feature coordinates.   Default 5.

* :code:`track` Track to search for next feature. Default to the first annotation track found.

`next` starts searching immediately after the current window and loops thourgh each chromosome until a feature is found.

Find
----

find
++++

:code:`find [-all] regex [track]`

Find the first record in `track` containing `regex`. The search for `regex` starts from the *end* of the current window (so the current window is not searched) and moves forward on the current chromosome. At the end  of the current chromosome move to the next chromosomes and then restart at  the start of the initial one. The search stops at the first match found. If `track` is omitted the first interval track found is searched.
The :code:`-all` flag will return the region containing **all** the regex matches.
Examples::

    find -all ACTB genes.gtf -> Find all the matches of ACTB
    find 'ACTB gene'         -> Find the first match of 'ACTB gene'

Use single quotes to define patterns containing spaces.

seqRegex
++++++++

:code:`seqRegex [-iupac] [-c] [regex]`

Find regex in reference sequence and show matches as an additional track.  Options:

* :code:`regex` Regex to search. If missing the seq regex track is removed.

* :code:`-iupac` Enable the interpretation of the IUPAC ambiguity code. NB: This option simply converts IUPAC chracters to the corresponding regex.

* :code:`-c` Enable case-sensitive matching. Default is to ignore case.

Examples::

    seqRegex ACTG        -> Case insensitive, actg matched
    seqRegex -c ACTG     -> Case sensitive, will not match actg
    seqRegex -iupac ARYG -> Interpret (converts) R as [AG] and Y as [CT]
    seqRegex             -> Disable regex matching track

To save matches to file, see the `print` command. This command is ignored if the reference fasta sequence is missing.

bookmark
++++++++

:code:`bookmark [name] | [-rm] | [-print] | [> [file]]`

Creates a track to save positions of interest. Without arguments, add the current position to the bookmark track. Options:

* :code:`name` give this name to the new bookmark.

* :code:`-rm` remove the bookmark matching *exactly* the current position.

* :code:`-print` prints to screen the list of current bookmarks.

* :code:`>` saves the bookmark track to file.

Examples::

    bookmark              -> Add the current position to bookmarks.
    bookmark myGene       -> Add the current position with name myGene
    bookmark -rm          -> Remove the bookmark exactly in this position
    bookmark > books.txt  -> Save to file books.txt
    bookmark -print       -> Show table of bookmarks



Display
-------

grep
++++

:code:`grep [-i = .*] [-e = ''] [-v] [track_regex = .*]...`

Similar to grep command, filter for features including or excluding patterns. Options:

* :code:`-i regex`  Show features matching this regex.

* :code:`-e regex` Exclude features matching this regex.

* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

* :code:`track_regex` Apply to tracks matched by `track_regex`.

*NOTES*

* For case insensitive matching prepend :code:`(?i)` to regex pattern. E.g. :code:`-i (?i)ACTB` to match also Actb

* Use *single quotes* to delimit patterns containing spaces e.g. :code:`-i 'ACTB gene'`

Regex `-i` and `-e` are applied to the raw lines as read from source file and it is applied only to annotation tracks (GFF, BED, VCF, etc). For example::

    grep -i RNA -e mRNA gtf gff

Will show the rows containing 'RNA' but will hide those containing 'mRNA', applies to tracks whose name matches 'gtf' or 'gff'.
With no arguments reset to default: :code:`grep -i .* -e ^$ .*` which means show everything, hide nothing, apply to all tracks.

awk
+++

:code:`awk [-off ...] [-F sep_re] [-v VAR=var] [-V] '<script>' [track_regex = .*]...`

Advanced feature filtering using awk syntax. awk offers finer control then :code:`grep` to filter records in tabular format.

Awk is column oriented. Awk splits each line into a list using a given regular expression as delimiter (default delimiter is the TAB character). To access an item, i.e. a column, use the syntax :code:`$n` where *n* is the position of the item in the list, e.g. :code:`$3` will access the third field (i.e. 3rd column). The variable :code:`$0` holds the entire line as single string.

Awk understands numbers and mathematical operators. With awk you can filter records by numeric values in one or more fields since numbers are handled as such. You can also perform arithmetic operations and filter on the results.

*OPTIONS*

* :code:`-off track_re ...`  Turn off awk filtering for tracks captured by the list of regexes.

* :code:`-F <sep_re>` Use regular expression <sep_re> as column separator. Default is '\t' (tab). To separate on white space use e.g. '\b' (backspace) or '\s' (any white space). Do not use ' '. 

* :code:`-v VAR=var` Pass to awk script the variable VAR with value var. Can be repeated.

* :code:`script` The awk script to be executed. Must wrapped in single quotes.

* :code:`-V` Invert selection: apply changes to the tracks not selected by list of track_regex

*EXAMPLES*

Note the use of single quotes to wrap the actual script and the use of double quotes inside the script.

* Filter for lines where the 4th column is between 10 and 100. Apply only to tracks matching '.gtf' or '.gff'::

    awk '$4 > 10 && $4 <= 100' .gtf .gff

* Filter for either perfect a match or by matching a regex on 3rd column. Apply to all tracks. The second example matches regex on the entire line (similar to grep), The third example also requires features to be on + strand::

    awk '$3 == "exon" || $3 \  ".*_codon"'
    
    awk '$0 \  ".*_codon"'
    
    awk '($3 == "exon" || $3 \  ".*_codon") && $7 == "+"'

* Filter for features size (assuming bed format) and for values after log10 transformation. For log10 we need to change base using ln(x)/ln(10)::

    awk '($3 - $2) > 1000 && (log($4)/log(10)) < 3.5'

* Remove awk filter for tracks captured by .gff and .gtf::

    awk -off .gtf .gff

With no args, turn off awk for all tracks.

*NOTES & LIMITATIONS*

* This is a java implementation of awk and it is independent on whether awk is on the local system. It should behave very similar to UNIX awk and therefore it has lots of functionalities. In fact, awk is a programming language in itself, search Google for more. The original code is from https://github.com/hoijui/Jawk

* Use awk only to filter features, do not use it to edit them. If features are changed by the awk script than nothing will be retained. This is because the awk command first collects the output from awk, then it matches the features in the current window with those collected from awk.

* Each line is processed independently of the others as a separate awk execution. This means that you cannot filter one line on the bases of previous or following lines.

* This awk is slow, about x10-100 times slower than UNIX awk. For few thousand records the slowdown should be acceptable. Other things being equal, use `grep` instead.

* The default delimiter is TAB not any white space as in UNIX awk.

* An invalid script throws an ugly stack trace to stderr. To be fixed.

featureDisplayMode
++++++++++++++++++

:code:`featureDisplayMode [-expanded | -collapsed | -oneline] [-v] [track_regex = .*]...`

Set how annotation features should be displayed.
 
* :code:`-expanded/-e` Put overalpping features on different lines (default).

* :code:`-collapsed/-c` Merge features with overlapping genomic coordinates.

* :code:`-oneline/-o` Merge features overlapping on screen coordinates. This option makes the track occupy only one line.

* :code:`-v` Invert selection: apply changes to tracks not selected by list of track_regex

* :code:`track_regex` List of regexes to select tracks. Default: .* (all tracks).

Without arguments toggle between expanded and collapsed mode. 

gap
+++

:code:`gap [-on | -off] [-v] [track_regex = .*]...`

Display features with or without a separating gap.  With :code:`gap -on` (default) features which on screen do not have at least one space separating them are moved to different lines. In this way it is clear where one feature starts and ends. If gap is unset (:code:`gap -off`) features are shown more packed.

:code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

Example with :code:`gap -on`::

    ||||||
          ||||||

With :code:`gap -off` these two features look like::

    ||||||||||||

As elsewhere, this command is applied to all tracks captured by the list of regexes.

gffNameAttr
+++++++++++

:code:`gffNameAttr [attribute_name = NULL | -na] [-v] [track_regex = .*]...`

GTF/GFF attribute to set the feature name or `-na` to suppress name.  Use attribute NULL to reset to default choice of attribute. To suppress printing of the name use `-na`. Bed features get their name from the 4th column. Applies to annotation tracks captured by the list `track_regex`.

:code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

Example, given the gtf feature::

    chr1 . CDS  10 99 . + 2 gene_id "PTGFRN"; transcript_id "NM_020440";

Use gene_name as feature name or transcript_id::

    gffNameAttr gene_name genes.gtf .*gff
    PTGFRN_CCCCCCCCC
    
    gffNameAttr transcript_id genes.gtf .*gff
    NM_020440_CCCCCC
    
    gffNameAttr -na
    CCCCCCCCCCCCCCCC <- Do not show name    



trackHeight
+++++++++++

:code:`trackHeight [-v] INT [track_regex = .*]...`

Set track height to INT lines of text for all tracks matching regexes.  Setting height to zero hides the track and skips the processing altogether. This is useful to speed up the browsing when large bam files are present. Use infoTrack to see which tracks are hidden.

:code:`-v` Invert selection: apply changes to tracks not selected by list of track_regex

Example::

    trackHeight 5 aln.*bam gtf`


ylim
++++

:code:`ylim [-v] <NUM|min|na> <NUM|min|na> [track_regex = .*]...`

Set the y-axis limit for all tracks matched by regexes. The first two arguments set the min and max limits. The 3rd argument is a list of regexes to capture the tracks to reset. Argument min and max can be:

* :code:`NUM` Numeric, fix the limits exactly to these values

* :code:`na` Scale tracks to their individual min and/or max

* :code:`min` and :code:`max` Set to the min and max of **all** tracks.

:code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

This command applies only to tracks displaying quantitative data on y-axis (e.g. bigwig, tdf), the other tracks are unaffected. Examples::

    ylim 0 50      -> Set min= 0 and max= 50 in all tracks.
    ylim 0 na      -> Set min to 0 and autoscale the max. Apply to all tracks
    ylim na na tdf -> Autoscale min and max. Apply to all tracks matching 'tdf'
    ylim min max   -> Set to the min and max of all tracks



colorTrack
++++++++++

:code:`colorTrack [-v] color [track_regex = .*]...`

Set colour for tracks matched by regex.  Colors can be specified by name or by a value between 0 and 255. If only the start of a color is given, the first name found starting with the given string is returned, e.g. 'darkv' is interpreted as 'darkviolet'. Names are case insensitive.

:code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

Available colours are from the Xterm256 palette: `colors here <http://jonasjacek.github.io/colors/>`_grey74[38;5;0;48;5;231m            251: [38;5;251mgrey78[38;5;0;48;5;231m
252: [38;5;252mgrey82[38;5;0;48;5;231m            253: [38;5;253mgrey85[38;5;0;48;5;231m            254: [38;5;254mgrey89[38;5;0;48;5;231m
255: [38;5;255mgrey93[38;5;0;48;5;231m            

Example::

    colorTrack cyan1 ts.*gtf ts.*bam 
    colorTrack 40                   <- By INT
    colorTrack darkv                <- Same as darkviolet



hideTitle
+++++++++

:code:`hideTitle [-on | -off] [-v] [track_regex = .*]...`

Set the display of the title line matched by track_regex.  Without argument -on or -off toggle between the two modes for all tracks matched by the list of regexes.

:code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex


editNames
+++++++++

:code:`editNames [-t] [-v] <pattern> <replacement> [track_re=.*]...`

Edit track names by substituting regex pattern with replacement. Pattern and replacement are required arguments, the default regex for track is '.*' (i.e. all tracks).

* :code:`-t` (test) flag shows what renaming would be done without actually editing the names.

* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

Use "" (empty double quotes) to replace pattern with nothing. Examples: Given track names 'fk123_hela.bam#1' and 'fk123_hela.bed#2'::

    editNames fk123_ ""       -> hela.bam#1, hela.bed#2
    editNames fk123_ "" bam   -> hela.bam#1, fk123_hela.bed#2
    editNames _ ' '           -> fk123 hela.bam#1,  fk123 hela.bed#2
    editNames ^.*# cells      -> cells#1, cells#2
    editNames ^ xx_           -> xx_fk123_hela.bam#1, xx_fk123_hela.bed#2 (add prefix)


dataCol
+++++++

:code:`dataCol [-v] [index = 4] [track_regex = .*]...`

Select data column for bedgraph tracks containing regex.  First column has index 1. This command applies only to tracks of type bedgraph.

:code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

For example, use column 5 on tracks containing #1 and #3::
 
    dataCol 5 #1 #3



print
+++++

:code:`print [-n INT] [-full] [-off] [-v] [track_regex = .*]... [>|>> file]`

Print lines for the tracks matched by `track_regex`.  Useful to show exactly what features are present in the current window. Features are filtered in/out according to the :code:`grep` command. Options:

* :code:`track_regex` Apply to tracks matched by one or more of these regexes.

* :code:`-n INT=10` Print up to this many lines, default 10. No limit if < 0.

* :code:`-clip` Clip lines longer than the screen width. This is the default.

* :code:`-full` Wrap lines longer than the screen width.

* :code:`-off` Turn off printing.

* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

* :code:`>` and :code:`>>` Write output to `file`. `>` overwrites and `>>` appends to existing file. The %r variable in the filename is expanded to the current genomic coordinates. Writing to file overrides options -n and -off, lines are written in full without limit.

Examples::

    print                        -> Print all tracks, same as `print .*`
    print -off                   -> Turn off printing for all tracks
    print genes.bed >> genes.txt -> Append features in track(s) 'genes.bed' to file

Currently `print` applies only to annotation tracks, other tracks are unaffected. Without options toggle tracks between OFF and CLIP mode.

Alignments
----------

rpm
+++

:code:`rpm [-on | -off] [-v] [track_regex = .*]`

Set display to reads per million for BAM and TDF files.
 
* :code:`-on | -off` Set mode on/off. Without arguments toggle between on and off.

* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

* :code:`track_regex` List of regexes to capture target tracks.

samtools
++++++++

:code:`samtools [-f INT=0] [-F INT=4] [-q INT=0] [-v] [track_re = .*] ...`

Apply samtools filters to alignment tracks captured by the list of track regexes. As *samtools view*, this command filters alignment records on the basis of the given flags:

* :code:`-F` Filter out flags with these bits set. NB: 4 is always set.

* :code:`-f` Require alignment to have these bits sets.

* :code:`-q` Require alignments to have MAPQ >= than this.

* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

Examples::

    samtools -q 10           -> Set mapq for all tracks. -f and -F reset to default
    samtools -F 1024 foo bar -> Set -F for all track containing re foo or bar
    samtools                 -> Reset all to default.


BSseq
+++++

:code:`BSseq [-on | -off] [-v] [track_regex = .*]...`

Set bisulfite mode for read tracks matched by regex. In bisulfite mode, the characters M and m mark methylated bases (i.e. unconverted C to T) and U and u are used for unmethylated bases (i.e. C converted to T). Upper case is used for reads on  forward strand, small case for reverse.

* :code:`-on | -off` Set mode. Without arguments toggle between on and off.

* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

* :code:`track_regex` List of regexes to capture target tracks.

Ignored without reference fasta sequence.

General
-------

setGenome
+++++++++

:code:`setGenome fasta|bam|genome`

Set genome and reference sequence. The genome, i.e. the list of contig and names and sizes, can be extracted from the fasta reference, from a bam file or from a genome identifier (e.g. hg19). If a fasta file is used also the reference sequence becomes available.

setConfig
+++++++++

:code:`setConfig tag|file`

Set color configuration. Configuration can be set with one of the built-in themes: 'black_on_white', 'white_on_black', 'metal'. Alternatively, configuration can be read from file. For examples files see 
https://github.com/dariober/ASCIIGenome/blob/master/resources/config/

Examples:
setConfig metal
setConfig /path/to/mytheme.conf

showGenome
++++++++++

:code:`showGenome`

Print the genome dictionary with a representation of chromosome sizes.  Example output::

    showGenome
    chrM  16571
	   chr1  249250621 ||||||||||||||||||||||||||||||
    chr2  243199373 |||||||||||||||||||||||||||||
    ...
    chr21 48129895  ||||||
    chr22 51304566  ||||||
    chrX  155270560 |||||||||||||||||||
    chrY  59373566  |||||||



infoTracks
++++++++++

:code:`infoTracks`

Print the name of the current tracks along with file name and format.  Hidden tracks are marked by an asterisk.

recentlyOpened
++++++++++++++

:code:`recentlyOpened [-grep = .*]`

List recently opened files.  Files are listed with their absolute path.

* :code:`-n INT` Return only the last INT files.

* :code:`-grep <pattern>` Filter for files (strings) matching pattern. Use single quotes to define patterns containing spaces, e.g. :code:`-grep 'goto chr1'`.

addTracks
+++++++++

:code:`addTracks [file or URL]...`

Add tracks from local or remote files.  For local files, glob characters (wildcard) are expanded as in Bash (but note that currently globs in directory names are not expanded.)
Examples::

    addTracks peaks.bed genes.*.gtf
    addTracks http://remote/host/peaks.bed


dropTracks
++++++++++

:code:`dropTracks [-t] [-v] track_regex [track_regex]...`

Drop tracks matching any of the listed regexes. * :code:`-t` (test) flag only shows which tracks would be removed but do not remove them.

* :code:`-v` Invert selection: apply changes to the tracks not selected by list of track_regex

Examples::

    dropTracks bam


orderTracks
+++++++++++

:code:`orderTracks [track_regex]...`

Reorder tracks according to the list of regexes or sort by name. Not all the tracks need to be listed, the missing ones follow the listed ones in unchanged order. Without arguments sort track by tag name.
For example, given the track list: `[hela.bam#1, hela.bed#2, hek.bam#3, hek.bed#4]`::

    orderTracks #2 #1   -> [hela.bed#2, hela.bam#1, hek.bam#3, hek.bed#4]
    orderTracks bam bed -> [hela.bam#1, hek.bam#3, hela.bed#2, hek.bed#4]
    orderTracks         -> name sort [hela.bam#1, hela.bed#2, hek.bam#3, hek.bed#4]


posHistory
++++++++++

:code:`posHistory [-n INT=10]`

List the visited positions. Recorded positions include the current and the previous sessions of ASCIIGenome.

:code:`-n INT` Show only the last INT positions. Show all if <= 0.

history
+++++++

:code:`history [-n INT] [-grep = .*]`

List the executed commands.  Commands executed in previous sessions of ASCIIGenome are in \ /.asciigenome_history

* :code:`-n INT` Return only the last INT commands.

* :code:`-grep <pattern>` Filter for commands (strings) matching pattern. Use single quotes to define patterns containing spaces, e.g. :code:`-grep 'goto chr1'`

save
++++

:code:`save [>>] [filename = chrom_start_end.txt']`

Save screenshot to file as text or pdf format. The default file name is generated from the current coordinates and the default format is plain text. If the file name has extension '.pdf' then save as pdf. To append to an existing file use :code:`>>`. The string :code:`%r` in the file name is replaced with the current coordinates. Examples::

    save mygene.txt    -> Save to mygene.txt as text
    save >> mygene.txt -> Append to mygene.txt
    save               -> Save to chrom_start-end.txt as text
    save .pdf          -> Save to chrom_start-end.pdf as pdf
    save mygene.%r.pdf -> Save to mygene.chr1_100-200.pdf as pdf



sessionSave
+++++++++++

:code:`sessionSave filename`

Experimental: Save the current settings to file suitable to be reloaded by ASCIIGenome. `sessionSave` writes to file a set of commands to reproduce the current settings: tracks, colors, heights etc. It's not meant to be a perfect replica, rather it's a shortcut to avoid re-typing commands. Example::

    sessionSave session.txt

Quit session and reload with::

    ASCIIGenome -x session.txt


sys
+++

:code:`sys [-L] command`

Execute a system command. By default the given :code:`command` is executed as a string passed to Bash as :code:`bash -c string`. With the :code:`-L` option the command is executed literally as it is. Note that with the :code:`-L` option globs are not expanded by Java. Examples::

    sys pwd                    <- Print working directory name
    sys ls *.bam               <- List files ending in .bam
    sys samtools index aln.bam <- Exec samtools

q
+

:code:`q`

Quit 

h
+

:code:`h -h`

h and -h show this help.
For help on commands: `command -h`, e.g. :code:`ylim -h` 


